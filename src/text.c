/*GENERATED BY TOOLS/CONCAT.PY (DO NOT EDIT)*/
#ifndef WAX_STD_TEXT
#define WAX_STD_TEXT
const char* TEXT_std_java = "public static <T> void w_arrRemove(ArrayList<T> a, int i, int n){a.subList(i,i+n).clear();}\n"
"public static <T> ArrayList<T> w_arrSlice(ArrayList<T> a, int i, int n){return new ArrayList<T>(a.subList(i,i+n));}\n"
"public static String w_strSlice(String a, int i, int n){return a.substring(i,i+n);}\n"
"public static <K,V> V w_mapGet(HashMap<K,V> map, K key, V defaultValue) {V v;return (((v = map.get(key)) != null) || map.containsKey(key))? v: defaultValue;}\n"
"public static boolean w_BOOL(int x){return x!=0;}\n"
"public static int w_INT(boolean x){return x?1:0;}\n"
"public static int w_NOT(int x){return (x==0)?1:0;}\n";
const char* TEXT_std_c = "#ifndef WAX_STD\n"
"#define WAX_STD\n"
"#include <stdlib.h>\n"
"#include <stdio.h>\n"
"#include <string.h>\n"
"#include <stdarg.h>\n"
"#include <stdint.h>\n"
"#include <math.h>\n"
"#define W_MIN(a,b) (((a)<(b))?(a):(b))\n"
"#define W_MAX(a,b) (((a)>(b))?(a):(b))\n"
"void *w_malloc(size_t size){void *mem = malloc(size);if(!mem){exit(-1);}return mem;}\n"
"void *w_realloc(void* curr_mem, size_t size){void *mem = realloc(curr_mem, size);if(!mem){exit(-1);}return mem;}\n"
"void w_free(void* x){if (x){free(x);}}\n"
"typedef struct w_arr_st {void* data;size_t len;size_t cap;size_t elem_size;} w_arr_t;\n"
"w_arr_t* w_arr_new_impl(int elem_size){w_arr_t* arr = (w_arr_t*)w_malloc(sizeof(w_arr_t));arr->elem_size = elem_size;arr->len = 0;arr->cap = 16;arr->data = w_malloc((arr->cap)*elem_size);return arr;}\n"
"w_arr_t* w_arr_new_ints(int count,...){va_list vals;w_arr_t* arr = (w_arr_t*)w_malloc(sizeof(w_arr_t));arr->elem_size = sizeof(int);arr->len = count;arr->cap = count;arr->data = w_malloc((arr->cap)*arr->elem_size);va_start(vals, count);for (int i = 0; i < count; i++) {((int*)arr->data)[i]=va_arg(vals, int);}va_end(vals);return arr;}\n"
"w_arr_t* w_arr_new_flts(int count,...){va_list vals;w_arr_t* arr = (w_arr_t*)w_malloc(sizeof(w_arr_t));arr->elem_size = sizeof(float);arr->len = count;arr->cap = count;arr->data = w_malloc((arr->cap)*arr->elem_size);va_start(vals, count);for (int i = 0; i < count; i++) {((float*)arr->data)[i]=(float)va_arg(vals, double);}va_end(vals);return arr;}\n"
"w_arr_t* w_arr_new_strs(int count,...){va_list vals;w_arr_t* arr = (w_arr_t*)w_malloc(sizeof(w_arr_t));arr->elem_size = sizeof(char*);arr->len = count;arr->cap = count;arr->data = w_malloc((arr->cap)*arr->elem_size);va_start(vals, count);for (int i = 0; i < count; i++) {((char**)arr->data)[i]=(char*)va_arg(vals, char*);}va_end(vals);return arr;}\n"
"int* w_vec_new_ints(int count,...){va_list vals;int* vec = (int*)w_malloc(sizeof(int)*count);va_start(vals, count);for (int i = 0; i < count; i++) {vec[i]=va_arg(vals, int);}va_end(vals);return vec;}\n"
"float* w_vec_new_flts(int count,...){va_list vals;float* vec = (float*)w_malloc(sizeof(float)*count);va_start(vals, count);for (int i = 0; i < count; i++) {vec[i]=(float)va_arg(vals, double);}va_end(vals);return vec;}\n"
"char** w_vec_new_strs(int count,...){va_list vals;char** vec = (char**)w_malloc(sizeof(char*)*count);va_start(vals, count);for (int i = 0; i < count; i++) {vec[i]=va_arg(vals, char*);}va_end(vals);return vec;}\n"
"#define w_arr_new(type)         (w_arr_new_impl(sizeof(type)))\n"
"#define w_arr_get(type,arr,i  ) (((type *)((arr)->data))[(i)])\n"
"#define w_arr_set(type,arr,i,x) (((type *)((arr)->data))[(i)]=(x))\n"
"void w_arr_insert_impl(w_arr_t* arr,int i) {if ((arr)->len >= (arr)->cap){(arr)->cap = (arr)->cap+W_MAX(4,(arr)->cap/2);(arr)->data = w_realloc((arr)->data, (arr)->elem_size*((arr)->cap));}if ((i) < (arr)->len){memmove((char*)((arr)->data)+((i)+1)*(arr)->elem_size,(char*)((arr)->data)+(i)*(arr)->elem_size,((arr)->len-(i))*(arr)->elem_size );}(arr)->len++;}\n"
"#define w_arr_insert(type,arr,i,x) { type tmp__x_ = x; int tmp__i_ = i; w_arr_t* tmp__a_ = arr; w_arr_insert_impl((tmp__a_),(tmp__i_)); (((type *)((tmp__a_)->data))[(tmp__i_)]=(tmp__x_)); }\n"
"void w_arr_remove(w_arr_t* arr,int i,int n) {memmove((char*)((arr)->data)+(i)*(arr)->elem_size,(char*)((arr)->data)+((i)+(n))*(arr)->elem_size,((arr->len)-(i)-(n))*(arr)->elem_size );(arr)->len-=(n);}\n"
"w_arr_t* w_arr_slice(w_arr_t*arr,int i,int n) {w_arr_t* brr = (w_arr_t*)w_malloc(sizeof(w_arr_t));brr->elem_size = (arr)->elem_size;brr->len = n;brr->cap = n;brr->data = w_malloc((brr->cap)*(brr->elem_size));memcpy((char*)(brr->data), (char*)((arr)->data) + (i), (n)*((arr)->elem_size));return brr;}\n"
"#define W_NUM_MAP_SLOTS 64\n"
"typedef struct w_slot_st {int keylen;void* key;int64_t data;struct w_slot_st* next;} w_slot_t;\n"
"typedef struct w_map_st {int key_is_ptr;size_t len;w_slot_t* slots[W_NUM_MAP_SLOTS];} w_map_t;\n"
"w_map_t* w_map_new(char key_is_ptr){w_map_t* map = (w_map_t*)w_malloc(sizeof(w_map_t));map->key_is_ptr = key_is_ptr;for (int i = 0; i < W_NUM_MAP_SLOTS; i++){map->slots[i] = NULL;}map->len = 0;return map;}\n"
"int w_map_hash(void* ptr, size_t len){int x = 0;for (size_t i = 0; i < len; i++){unsigned char y = *((unsigned char*)((unsigned char*)ptr+i));x ^= y;}x %= W_NUM_MAP_SLOTS;return x;}\n"
"void w_map_set(w_map_t* map, int64_t key, int64_t data){int keylen;void* keyptr;if (map->key_is_ptr){keylen = strlen((char*)key);keyptr = (char*)key;}else{keylen = sizeof(key);keyptr = &key;}int k = w_map_hash(keyptr,keylen);w_slot_t* it = map->slots[k];while (it){if (keylen == it->keylen){if (memcmp(it->key,keyptr,keylen)==0){it->data = data;return;}}it = it -> next;}w_slot_t* nxt = map->slots[k];w_slot_t* slot = (w_slot_t*)w_malloc(sizeof(w_slot_t));slot->key = w_malloc(keylen);memcpy(slot->key,keyptr,keylen);slot->data=data;slot->next = nxt;slot->keylen = keylen;map->slots[k] = slot;map->len++;}\n"
"int64_t w_map_get(w_map_t* map, int64_t key){int keylen;void* keyptr;if (map->key_is_ptr){keylen = strlen((char*)key);keyptr = (char*)key;}else{keylen = sizeof(key);keyptr = &key;}int k = w_map_hash(keyptr,keylen);w_slot_t* it = map->slots[k];while (it){if (keylen == it->keylen){if (memcmp(it->key,keyptr,keylen)==0){return it->data;}}it = it -> next;}return 0;}\n"
"void w_map_remove(w_map_t* map, int64_t key){size_t keylen;void* keyptr;if (map->key_is_ptr){keylen = strlen((char*)key);keyptr = (char*)key;}else{keylen = sizeof(key);keyptr = &key;}int k = w_map_hash(keyptr,keylen);w_slot_t* it = map->slots[k];w_slot_t* prev = NULL;while (it){if (keylen == it->keylen){if (memcmp(it->key,keyptr,keylen)==0){if (prev){prev->next = it->next;}else{map->slots[k] = it->next;}map->len--;w_free(it->key);w_free(it);return;}}prev = it;it = it -> next;}return;}\n"
"int w_reinterp_f2i(float x){return *((int *)&x);}\n"
"float w_reinterp_i2f(int x){return *((float *)&x);}\n"
"typedef struct {char data[32];} w_shortstr_t;\n"
"w_shortstr_t w_int2str(int x){w_shortstr_t str;sprintf(str.data, \"%d\", x);return str;}\n"
"w_shortstr_t w_flt2str(float x){w_shortstr_t str;sprintf(str.data, \"%g\", x);return str;}\n"
"char* w_str_new(char* x){size_t l = strlen(x);char* str = (char*)w_malloc(l);strncpy(str,x,l);str[l] = 0;return str;}\n"
"char* w_str_cat(char* x, char* y){size_t l0 = strlen(x);size_t l1 = strlen(y);x = (char*)w_realloc(x,l0+l1+1);memcpy(x+l0,y,l1);x[l0+l1] = 0;return x;}\n"
"char* w_str_add(char* x, int y){char c = (char)y;size_t l = strlen(x);x = (char*)w_realloc(x,l+2);x[l] = c;x[l+1]=0;return x;}\n"
"char* w_str_cpy(char* x, int i, int l){char* y = (char*)w_malloc(l+1);memcpy(y,x+i,l);y[l] = 0;return y;}\n"
"void w_free_arr(w_arr_t* x){if (x){w_free(x->data);w_free(x);}}\n"
"void w_free_map(w_map_t* map){if (!map){return;}for (int i = 0; i < W_NUM_MAP_SLOTS; i++){w_slot_t* it = map->slots[i];while (it){w_slot_t* nxt = it->next;w_free(it->key);w_free(it);it = nxt;}}w_free(map);}\n"
"#endif\n";
const char* TEXT_std_py = "def w_arr_remove(a,i,n):del a[i:i+n]\n"
"def w_slice(a,i,n):return a[i:i+n]\n"
"def w_map_get(m,k,d):\n"
"    try:return m[k]\n"
"    except:return d\n"
"def w_map_remove(m,k):\n"
"    try:del m[k]\n"
"    except:pass\n";
const char* TEXT_std_swift = "class w_Arr<T>{\n"
"  var data : Array<T> = [];\n"
"  init(data:[T]){self.data = data;}\n"
"  init(zero:T,n:Int){self.data = Array<T>(repeating:zero,count:n);}\n"
"  func remove(i:Int,n:Int){self.data.removeSubrange(i..<(i+n));}\n"
"  func slice(i:Int,n:Int)->w_Arr<T>{\n"
"    return w_Arr<T>(data:Array(self.data[i..<(i+n)]));\n"
"  }\n"
"}\n"
"class w_Map<K:Hashable,V>{\n"
"  var data : Dictionary<K,V> = [:];\n"
"}\n"
"static func w_charCode(x:String) -> Int{\n"
"  return (Int)(x.unicodeScalars[x.unicodeScalars.startIndex].value);\n"
"}\n"
"static func w_strSlice(x:String,i:Int,n:Int)->String{\n"
"  return String(Array(x)[i..<(i+n)]);\n"
"}\n"
"static func w_INT(x:Bool)->Int{return x ? 1 : 0;}\n"
"static func w_BOOL(x:Int)->Bool{return x != 0;}\n"
"static func w_NOT(x:Int)->Int{return (x == 0) ? 1 : 0;}\n"
"static func w_strBang(x:String?)->String{return x!;}\n";
const char* TEXT_std_cs = "public static V w_mapGet<K,V>(Dictionary<K,V> map, K key, V defaultValue) {V v;if (map.TryGetValue(key,out v)){return v;}return defaultValue;}\n"
"public static bool w_BOOL(int x){return x!=0;}\n"
"public static int w_INT(bool x){return x?1:0;}\n"
"public static int w_NOT(int x){return (x==0)?1:0;}\n";
const char* TEXT_std_cpp = "template <typename T>\n"
"inline void w_arr_insert (std::vector<T>* arr, int i, T x){arr->insert(arr->begin()+i,x);}\n"
"template <typename T>\n"
"inline void w_arr_remove (std::vector<T>* arr, int i, int n){arr->erase(arr->begin()+i,arr->begin()+i+n);}\n"
"template <typename T>\n"
"inline std::vector<T>* w_arr_slice (std::vector<T>* arr, int i, int n){return new std::vector<T>(arr->begin()+i,arr->begin()+i+n);}\n"
"template <typename K, typename V>\n"
"inline V w_map_get (std::map<K,V>* m, K k, V defau){typename std::map<K,V>::iterator it = m->find(k);if (it != m->end()){return it->second;}return defau;}\n"
"template <typename T, std::size_t N>\n"
"inline std::array<T,N>* w_vec_init (T v){std::array<T,N>* vec = new std::array<T,N>;vec->fill(v);return vec;}\n";
const char* TEXT_std_ts = "const w_slice=(x:Array<any>|string,i:number,n:number)=>x.slice(i,i+n);\n";
const char* TEXT_std_lua = "function w_trunc(x)         if x < 0 then return math.ceil(x) else return math.floor(x) end end\n"
"function w_vec_init(z,n)    local x = {} for i=1,n do x[i]=z end return x end\n"
"function w_arr_slice(x,i,n) local y = {} for j=(i+1),(i+n) do y[j-i]=x[j] end return y end\n"
"function w_arr_remove(x,i,n)for j=(i+n),(i+1),-1 do table.remove(x,j) end end\n"
"function w_map_len(x)       local cnt = 0 for k,v in pairs(x) do cnt = cnt + 1 end return cnt end\n"
"function w_strcpy(x,i,n)    return string.sub(x,i+1,i+n) end\n";
const char* TEXT_math_wax = "(@pragma once)  (extern acos   (param x float) (result float)) (extern asin   (param x float) (result float)) (extern atan   (param x float) (result float)) (extern cos    (param x float) (result float)) (extern cosh   (param x float) (result float)) (extern sin    (param x float) (result float)) (extern sinh   (param x float) (result float)) (extern tan    (param x float) (result float)) (extern tanh   (param x float) (result float)) (extern exp    (param x float) (result float)) (extern log    (param x float) (result float)) (extern sqrt   (param x float) (result float)) (extern ceil   (param x float) (result float)) (extern floor  (param x float) (result float)) (extern fabs   (param x float) (result float)) (extern round  (param x float) (result float)) (extern atan2  (param x float) (param y float) (result float)) (extern pow    (param x float) (param y float) (result float)) (extern fmax   (param x float) (param y float) (result float)) (extern fmin   (param x float) (param y float) (result float)) (extern abs    (param x int) (result int)) (extern random (result float)) (extern INFINITY float)   (@if TARGET_C 1 	(asm \"#define random() ((float)rand()/RAND_MAX)\n\") )  (@if TARGET_CPP 1 	(asm \"#define random() ((float)rand()/RAND_MAX)\n\") )  (@if TARGET_JAVA 1 	(asm \"public static float fabs(float x){return Math.abs(x);}\n\") 	(asm \"public static float fmin(float x, float y){return Math.min(x,y);}\n\") 	(asm \"public static float fmax(float x, float y){return Math.max(x,y);}\n\") 	(asm \"public static final float INFINITY = Float.POSITIVE_INFINITY;\n\") )  (@if TARGET_TS 1 	(asm \"const acos  = Math.acos  ;\n\") 	(asm \"const asin  = Math.asin  ;\n\") 	(asm \"const atan  = Math.atan  ;\n\") 	(asm \"const cos   = Math.cos   ;\n\") 	(asm \"const sin   = Math.sin   ;\n\") 	(asm \"const tan   = Math.tan   ;\n\") 	(asm \"const exp   = Math.exp   ;\n\") 	(asm \"const log   = Math.log   ;\n\") 	(asm \"const sqrt  = Math.sqrt  ;\n\") 	(asm \"const ceil  = Math.ceil  ;\n\") 	(asm \"const floor = Math.floor ;\n\") 	(asm \"const fabs  = Math.abs   ;\n\") 	(asm \"const fmin  = Math.min   ;\n\") 	(asm \"const fmax  = Math.max   ;\n\") 	(asm \"const atan2 = Math.atan2 ;\n\") 	(asm \"const pow   = Math.pow   ;\n\") 	(asm \"const abs   = Math.abs   ;\n\") 	(asm \"const round = Math.round ;\n\") 	(asm \"const random= Math.random;\n\") 	(asm \"const INFINITY = Infinity;\n\") 	(asm \"// @ts-ignore\n\") 	(asm \"const sinh  = Math.sinh ;\n\") 	(asm \"// @ts-ignore\n\") 	(asm \"const cosh  = Math.cosh ;\n\") 	(asm \"// @ts-ignore\n\") 	(asm \"const tanh  = Math.tanh ;\n\") )  (@if TARGET_PY 1 	(asm \"from math import *\n\") 	(asm \"from random import random\n\") 	(asm \"INFINITY = float('inf')\n\") 	(asm \"fabs = abs\n\") 	(asm \"fmin = min\n\") 	(asm \"fmax = max\n\") )   (@if TARGET_CS 1 	(asm \"public static Func<double,double> acos     = Math.Acos   ;\n\") 	(asm \"public static Func<double,double> asin     = Math.Asin   ;\n\") 	(asm \"public static Func<double,double> atan     = Math.Atan   ;\n\") 	(asm \"public static Func<double,double> cos      = Math.Cos    ;\n\") 	(asm \"public static Func<double,double> sin      = Math.Sin    ;\n\") 	(asm \"public static Func<double,double> tan      = Math.Tan    ;\n\") 	(asm \"public static Func<double,double> exp      = Math.Exp    ;\n\") 	(asm \"public static Func<double,double> log      = Math.Log    ;\n\") 	(asm \"public static Func<double,double> sqrt     = Math.Sqrt   ;\n\") 	(asm \"public static Func<double,double> ceil     = Math.Ceiling;\n\") 	(asm \"public static Func<double,double> floor    = Math.Floor  ;\n\") 	(asm \"public static Func<double,double> fabs     = Math.Abs    ;\n\") 	(asm \"public static Func<double,double> sinh     = Math.Sinh   ;\n\") 	(asm \"public static Func<double,double> cosh     = Math.Cosh   ;\n\") 	(asm \"public static Func<double,double> tanh     = Math.Tanh   ;\n\") 	(asm \"public static Func<double,double> round    = Math.Round  ;\n\") 	(asm \"public static Func<int,int> abs            = Math.Abs    ;\n\") 	(asm \"public static Func<double,double,double> atan2 = Math.Atan2 ;\n\") 	(asm \"public static Func<double,double,double> pow   = Math.Pow   ;\n\") 	(asm \"public static Func<double,double,double> fmin  = Math.Min   ;\n\") 	(asm \"public static Func<double,double,double> fmax  = Math.Max   ;\n\") 	(asm \"public static float INFINITY = Single.PositiveInfinity;\n\") 	(asm \"public static Random w_RNG = new Random();\n\") 	(asm \"public static float random(){ return (float)w_RNG.NextDouble(); }\n\")  )   (@if TARGET_SWIFT 1 	(asm \"static var w_seed : UInt32 = 0x5EED;\n\") 	(asm \"static func random()->Float{w_seed^=(w_seed<<17);w_seed^=(w_seed>>13);w_seed^=(w_seed<<5);return Float(w_seed)/Float(4294967295);}\n\") 	(asm \"static var INFINITY : Float = Float.infinity\n\") 	(asm \"static func acos (x:Float)->Float{return Foundation.acos (x);}\n\") 	(asm \"static func asin (x:Float)->Float{return Foundation.asin (x);}\n\") 	(asm \"static func atan (x:Float)->Float{return Foundation.atan (x);}\n\") 	(asm \"static func cos  (x:Float)->Float{return Foundation.cos  (x);}\n\") 	(asm \"static func cosh (x:Float)->Float{return Foundation.cosh (x);}\n\") 	(asm \"static func sin  (x:Float)->Float{return Foundation.sin  (x);}\n\") 	(asm \"static func sinh (x:Float)->Float{return Foundation.sinh (x);}\n\") 	(asm \"static func tan  (x:Float)->Float{return Foundation.tan  (x);}\n\") 	(asm \"static func tanh (x:Float)->Float{return Foundation.tanh (x);}\n\") 	(asm \"static func exp  (x:Float)->Float{return Foundation.exp  (x);}\n\") 	(asm \"static func log  (x:Float)->Float{return Foundation.log  (x);}\n\") 	(asm \"static func sqrt (x:Float)->Float{return Foundation.sqrt (x);}\n\") 	(asm \"static func ceil (x:Float)->Float{return Foundation.ceil (x);}\n\") 	(asm \"static func floor(x:Float)->Float{return Foundation.floor(x);}\n\") 	(asm \"static func fabs (x:Float)->Float{return Swift.abs   (x);}\n\") 	(asm \"static func round(x:Float)->Float{return Foundation.round(x);}\n\") 	(asm \"static func atan2(x:Float,y:Float)->Float{return Foundation.atan2(x,y);}\n\") 	(asm \"static func pow  (x:Float,y:Float)->Float{return Foundation.pow  (x,y);}\n\") 	(asm \"static func fmax (x:Float,y:Float)->Float{return Foundation.fmax (x,y);}\n\") 	(asm \"static func fmin (x:Float,y:Float)->Float{return Foundation.fmin (x,y);}\n\") 	(asm \"static func abs  (x:Int)          ->Int  {return Swift.abs   (x);  }\n\") )  (@if TARGET_LUA 1 	(asm \"do for k,v in pairs(math) do _G[k]=v end end\n\") 	(asm \"function round(x) return x>=0 and math.floor(x+0.5) or math.ceil(x-0.5) end\n\") 	(asm \"local INFINITY = huge\n\") 	(asm \"local fmax = max\n\") 	(asm \"local fmin = min\n\") 	(asm \"local fabs = abs\n\n\") )\n";
const char* TEXT_math_wat = "(import \"Math\" \"log\"    (func $log   (param f32) (result f32)))\n"
"(import \"Math\" \"exp\"    (func $exp   (param f32) (result f32)))\n"
"(import \"Math\" \"cos\"    (func $cos   (param f32) (result f32)))\n"
"(import \"Math\" \"sin\"    (func $sin   (param f32) (result f32)))\n"
"(import \"Math\" \"tan\"    (func $tan   (param f32) (result f32)))\n"
"(import \"Math\" \"cosh\"   (func $cosh  (param f32) (result f32)))\n"
"(import \"Math\" \"sinh\"   (func $sinh  (param f32) (result f32)))\n"
"(import \"Math\" \"tanh\"   (func $tanh  (param f32) (result f32)))\n"
"(import \"Math\" \"acos\"   (func $acos  (param f32) (result f32)))\n"
"(import \"Math\" \"asin\"   (func $asin  (param f32) (result f32)))\n"
"(import \"Math\" \"atan2\"  (func $atan2 (param f32) (param  f32) (result f32)))\n"
"(import \"Math\" \"pow\"    (func $pow   (param f32) (param  f32) (result f32)))\n"
"(import \"Math\" \"random\" (func $random            (result f32)))\n"
"\n"
"(func $fmax (param $x f32) (param $y f32) (result f32) (f32.max (local.get $x) (local.get $y)))\n"
"(func $fmin (param $x f32) (param $y f32) (result f32) (f32.min (local.get $x) (local.get $y)))\n"
"(func $fabs (param $x f32) (result f32) (f32.abs (local.get $x)))\n"
"(func $floor (param $x f32) (result f32) (f32.floor (local.get $x)))\n"
"(func $ceil (param $x f32) (result f32) (f32.ceil (local.get $x)))\n"
"(func $sqrt (param $x f32) (result f32) (f32.sqrt (local.get $x)))\n"
"(func $round (param $x f32) (result f32) (f32.nearest (local.get $x)))\n"
"\n"
"(func $abs (param $x i32) (result i32)\n"
"  (if (i32.lt_s (local.get $x) (i32.const 0))(then\n"
"      (i32.sub (i32.const 0) (local.get $x))\n"
"      return\n"
"  ))\n"
"  (local.get $x)\n"
")\n"
"\n"
"(global $INFINITY f32 (f32.const 340282346638528859811704183484516925440))\n";
const char* TEXT_std_arr_wat = ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
";;                                  ;;\n"
";;                                  ;;\n"
";;               ARRAY              ;;\n"
";;                                  ;;\n"
";;                                  ;;\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
";; addapted from https://github.com/LingDong-/wasm-fun\n"
"\n"
";;   Continous, resizable storage for a sequence of values,\n"
";;   similar to C++ vector<T>\n"
";;\n"
";;   +--------------------+\n"
";;   |data|length|capacity|\n"
";;   +-|------------------+\n"
";;     |        +---------------------------\n"
";;     `------> |elem 0|elem 1|elem 2|......\n"
";;              +---------------------------\n"
"\n"
";; struct arr {\n"
";;   i32/f32/(void*) data\n"
";;   int length\n"
";;   int capacity\n"
";; }\n"
"\n"
"(global $wax::DEFAULT_CAPACITY (mut i32) (i32.const 8))\n"
"\n"
";; (internal) getter/setters for arr struct fields\n"
"\n"
"(func $wax::_arr_set_data (param $ptr i32) (param $data i32)\n"
"  (i32.store (local.get $ptr) (local.get $data))\n"
")\n"
"(func $wax::_arr_set_length (param $ptr i32) (param $length i32)\n"
"  (i32.store (i32.add (local.get $ptr) (i32.const 4)) (local.get $length))\n"
")\n"
"(func $wax::_arr_set_capacity (param $ptr i32) (param $capacity i32)\n"
"  (i32.store (i32.add (local.get $ptr) (i32.const 8)) (local.get $capacity))\n"
")\n"
"(func $wax::_arr_get_data (param $ptr i32) (result i32)\n"
"  (i32.load (local.get $ptr))\n"
")\n"
"(func $wax::_arr_get_capacity (param $ptr i32) (result i32)\n"
"  (i32.load (i32.add (local.get $ptr) (i32.const 8)))\n"
")\n"
"\n"
";; returns length of an array given an arr pointer\n"
"(func $wax::arr_length (param $ptr i32) (result i32)\n"
"  (i32.load (i32.add (local.get $ptr) (i32.const 4)) )\n"
")\n"
"\n"
";; initialize a new arr, returns a pointer to it\n"
";; elem_size: size of each element, in bytes\n"
"(func $wax::arr_new (param $len i32) (result i32)\n"
"  (local $ptr i32)\n"
"  (local $cap i32)\n"
"  (local $data i32)\n"
"  (if (i32.lt_u (local.get $len) (global.get $wax::DEFAULT_CAPACITY)) (then\n"
"    (local.set $cap (global.get $wax::DEFAULT_CAPACITY))\n"
"  )(else\n"
"    (local.set $cap (local.get $len))\n"
"  ))\n"
"  (local.set $ptr (call $wax::malloc (i32.const 12)))\n"
"  (local.set $data (call $wax::calloc (i32.mul (local.get $cap) (i32.const 4))))\n"
"  (call $wax::_arr_set_data (local.get $ptr) (local.get $data))\n"
"  (call $wax::_arr_set_length (local.get $ptr) (local.get $len))\n"
"  (call $wax::_arr_set_capacity (local.get $ptr) (local.get $cap))\n"
"  (local.get $ptr)\n"
")\n"
"\n"
";; free allocated memory given an arr pointer\n"
"(func $wax::arr_free (param $a i32)\n"
"  (call $wax::free (call $wax::_arr_get_data (local.get $a)))\n"
"  (call $wax::free (local.get $a))\n"
")\n"
"\n"
"\n"
"\n"
";; get ith element of an array\n"
"(func $wax::arr_get (param $a i32) (param $i i32) (result i32)\n"
"  (local $data i32)\n"
"  (local $elem_size i32)\n"
"  (local.set $data (call $wax::_arr_get_data (local.get $a)))\n"
"  (local.set $elem_size (i32.const 4))\n"
"  (i32.load (i32.add (i32.mul (local.get $i) (local.get $elem_size)) (local.get $data)))\n"
")\n"
"\n"
";; set ith element of an array\n"
"(func $wax::arr_set (param $a i32) (param $i i32) (param $v i32)\n"
"  (local $data i32)\n"
"  (local $elem_size i32)\n"
"  (local.set $data (call $wax::_arr_get_data (local.get $a)))\n"
"  (local.set $elem_size (i32.const 4))\n"
"  (i32.store (i32.add (i32.mul (local.get $i) (local.get $elem_size)) (local.get $data)) (local.get $v))\n"
")\n"
"\n"
";; remove n elements from an array starting at index i\n"
"(func $wax::arr_remove (param $a i32) (param $i i32) (param $n i32)\n"
"  (local $data i32)\n"
"  (local $elem_size i32)\n"
"  (local $length i32)\n"
"  (local $offset i32)\n"
"\n"
"  (local.set $length (call $wax::arr_length (local.get $a)))\n"
"  (local.set $data (call $wax::_arr_get_data (local.get $a)))\n"
"  (local.set $elem_size (i32.const 4))\n"
"\n"
"  (local.set $offset \n"
"    (i32.add (local.get $data) (i32.mul (local.get $i) (local.get $elem_size) ))\n"
"  )\n"
"\n"
"  (call $wax::memmove \n"
"    (local.get $offset)\n"
"    (i32.add (local.get $offset) (i32.mul (local.get $n) (local.get $elem_size)))\n"
"    (i32.mul (i32.sub (local.get $length) (i32.add (local.get $i) (local.get $n)) ) (local.get $elem_size))\n"
"  )\n"
"  (call $wax::_arr_set_length  (local.get $a) (i32.sub (local.get $length) (local.get $n) ))\n"
")\n"
"\n"
"\n"
";; add an element to the end of the array\n"
";; does not write the element, instead, returns a pointer\n"
";; to the new last element for the user to write at\n"
"(func $wax::arr_push (param $a i32) (result i32)\n"
"  (local $length i32)\n"
"  (local $capacity i32)\n"
"  (local $data i32)\n"
"  (local $elem_size i32)\n"
"\n"
"  (local.set $length (call $wax::arr_length (local.get $a)))\n"
"  (local.set $capacity (call $wax::_arr_get_capacity (local.get $a)))\n"
"  (local.set $data (call $wax::_arr_get_data (local.get $a)))\n"
"  (local.set $elem_size (i32.const 4))\n"
"\n"
"  (if (i32.lt_u (local.get $length) (local.get $capacity) ) (then) (else\n"
"    (local.set $capacity (i32.add\n"
"      (i32.add (local.get $capacity) (i32.const 1))\n"
"      (local.get $capacity)\n"
"    ))\n"
"    (call $wax::_arr_set_capacity (local.get $a) (local.get $capacity))\n"
"\n"
"    (local.set $data \n"
"      (call $wax::realloc (local.get $data) (i32.mul (local.get $elem_size) (local.get $capacity) ))\n"
"    )\n"
"    (call $wax::_arr_set_data (local.get $a) (local.get $data))\n"
"  ))\n"
"  (call $wax::_arr_set_length (local.get $a) (i32.add (local.get $length) (i32.const 1)))\n"
"  \n"
"  ;; (i32.store (i32.add (local.get $data) (i32.mul (local.get $length) (local.get $elem_size))) (i32.const 0))\n"
"\n"
"  (i32.add (local.get $data) (i32.mul (local.get $length) (local.get $elem_size)))\n"
")\n"
"\n"
";; insert into an array at given index\n"
"(func $wax::arr_insert (param $a i32) (param $i i32) (param $v i32)\n"
"  (local $data i32)\n"
"  (local $elem_size i32)\n"
"  (local $length i32)\n"
"  (local $offset i32)\n"
"\n"
"  (local.set $length (call $wax::arr_length (local.get $a)))\n"
"\n"
"  (drop (call $wax::arr_push (local.get $a)))\n"
"\n"
"  (local.set $data (call $wax::_arr_get_data (local.get $a)))\n"
"  (local.set $elem_size (i32.const 4))\n"
"\n"
"  (local.set $offset \n"
"    (i32.add (local.get $data) (i32.mul (local.get $i) (local.get $elem_size) ))\n"
"  )\n"
"\n"
"  (call $wax::memmove\n"
"    (i32.add (local.get $offset) (local.get $elem_size))\n"
"    (local.get $offset)\n"
"    (i32.mul \n"
"      (i32.sub (local.get $length) (local.get $i) ) \n"
"      (local.get $elem_size)\n"
"    )\n"
"  )\n"
"\n"
"  (i32.store (local.get $offset) (local.get $v))\n"
"\n"
")\n"
"\n"
";; slice an array, producing a copy of a range of elements \n"
";; i = starting index (inclusive), j = stopping index (exclusive)\n"
";; returns pointer to new array\n"
"(func $wax::arr_slice (param $a i32) (param $i i32) (param $n i32) (result i32)\n"
"  (local $a_length i32)\n"
"  (local $length i32)\n"
"  (local $elem_size i32)\n"
"  (local $ptr i32)\n"
"  (local $data i32)\n"
"  (local $j i32)\n"
"\n"
"  (local.set $j (i32.add (local.get $i) (local.get $n)))\n"
"\n"
"  (local.set $a_length (call $wax::arr_length (local.get $a)))\n"
"\n"
"  (if (i32.lt_s (local.get $i) (i32.const 0) )(then\n"
"    (local.set $i (i32.add (local.get $a_length) (local.get $i)))\n"
"  ))\n"
"  (if (i32.lt_s (local.get $j) (i32.const 0) )(then\n"
"    (local.set $j (i32.add (local.get $a_length) (local.get $j)))\n"
"  ))\n"
"\n"
"  (local.set $length (i32.sub (local.get $j) (local.get $i)))\n"
"  (local.set $elem_size (i32.const 4))\n"
"\n"
"  (local.set $ptr (call $wax::malloc (i32.const 12)))\n"
"  (local.set $data (call $wax::malloc (i32.mul (local.get $length) (local.get $elem_size))))\n"
"  (call $wax::_arr_set_data (local.get $ptr) (local.get $data))\n"
"  (call $wax::_arr_set_length (local.get $ptr) (local.get $length))\n"
"  (call $wax::_arr_set_capacity (local.get $ptr) (local.get $length))\n"
"\n"
"  (call $wax::memcpy (local.get $data) \n"
"    (i32.add\n"
"      (call $wax::_arr_get_data (local.get $a))\n"
"      (i32.mul (local.get $i) (local.get $elem_size))\n"
"    )\n"
"    (i32.mul (local.get $length) (local.get $elem_size))\n"
"  )\n"
"\n"
"  (local.get $ptr)\n"
")\n"
"\n"
"\n";
const char* TEXT_std_str_wat = ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
";;                                  ;;\n"
";;                                  ;;\n"
";;              STRING              ;;\n"
";;                                  ;;\n"
";;                                  ;;\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
"\n"
"(func $wax::fmod (param $x f32) (param $y f32) (result f32)\n"
"  (f32.sub (local.get $x) (f32.mul (local.get $y) (f32.trunc (f32.div (local.get $x) (local.get $y)) )))\n"
")\n"
"\n"
"(func $wax::str_new (param $ptr i32) (result i32)\n"
"  (if (i32.eqz (local.get $ptr))(then\n"
"    (call $wax::calloc (i32.const 1))\n"
"    return\n"
"  ))\n"
"  (call $wax::str_slice (local.get $ptr) (i32.const 0) (call $wax::str_len (local.get $ptr)) )\n"
"  return\n"
")\n"
"\n"
"(func $wax::str_get (param $ptr i32) (param $i i32) (result i32)\n"
"  (i32.load8_s (i32.add (local.get $ptr) (local.get $i)))\n"
"  return\n"
")\n"
"\n"
"(func $wax::str_add (param $ptr i32) (param $c i32) (result i32)\n"
"  (local $l i32)\n"
"  (local.set $l (call $wax::str_len (local.get $ptr)))\n"
"  (local.set $ptr (call $wax::realloc (local.get $ptr) (i32.add (local.get $l) (i32.const 2) ) ) )\n"
"  (i32.store8 (i32.add (local.get $ptr) (local.get $l)) (local.get $c)  )\n"
"  (i32.store8 (i32.add (i32.add (local.get $ptr) (local.get $l)) (i32.const 1)) (i32.const 0)  )\n"
"\n"
"  (local.get $ptr)\n"
"  (return)\n"
")\n"
"\n"
"(func $wax::str_cat (param $s0 i32) (param $s1 i32) (result i32)\n"
"  (local $l0 i32)\n"
"  (local $l1 i32)\n"
"  (local.set $l0 (call $wax::str_len (local.get $s0)))\n"
"  (local.set $l1 (call $wax::str_len (local.get $s1)))\n"
"\n"
"  (local.set $s0 (call $wax::realloc (local.get $s0) (i32.add (i32.add (local.get $l0) (local.get $l1) ) (i32.const 1)) ))\n"
"\n"
"  (call $wax::memcpy (i32.add (local.get $s0) (local.get $l0)) (local.get $s1) (local.get $l1) )\n"
"  (i32.store8 (i32.add (i32.add (local.get $s0) (local.get $l0)) (local.get $l1)) (i32.const 0)  )\n"
"  (local.get $s0)\n"
"  return\n"
")\n"
"\n"
"(func $wax::str_cmp (param $s0 i32) (param $s1 i32) (result i32)\n"
"  (local $offset i32)\n"
"  (local $x i32)\n"
"  (local $y i32)\n"
"  (local.set $offset (i32.const 0))\n"
"  loop $cmp\n"
"    (local.set $x (i32.load8_u (i32.add (local.get $s0) (local.get $offset))) )\n"
"    (local.set $y (i32.load8_u (i32.add (local.get $s1) (local.get $offset))) )\n"
"\n"
"    (if (i32.eq (local.get $x) (local.get $y)) (then\n"
"      (if (i32.eqz (local.get $x)) (then\n"
"        (i32.const 1)\n"
"        return\n"
"      ))\n"
"    )(else\n"
"      (i32.const 0)\n"
"      return\n"
"    ))\n"
"\n"
"    (local.set $offset (i32.add (local.get $offset) (i32.const 1)))\n"
"    (br $cmp)\n"
"  end\n"
"  (i32.const 0) ;;impossible, just shut compiler up\n"
"  return\n"
")\n"
"\n"
"(func $wax::str_len (param $ptr i32) (result i32)\n"
"  (local $offset i32)\n"
"  (local.set $offset (i32.const 0))\n"
"  loop $zero\n"
"    (if (i32.load8_u (i32.add (local.get $ptr) (local.get $offset))) (then\n"
"      (local.set $offset (i32.add (local.get $offset) (i32.const 1)))\n"
"      (br $zero)\n"
"    ))\n"
"  end\n"
"  (local.get $offset)\n"
"  return\n"
")\n"
"\n"
"(func $wax::str_slice (param $ptr i32) (param $i i32) (param $n i32) (result i32)\n"
"  (local $nptr i32)\n"
"  (local.set $nptr (call $wax::malloc (i32.add (local.get $n) (i32.const 1))))\n"
"  (call $wax::memcpy \n"
"    (local.get $nptr) \n"
"    (i32.add (local.get $ptr) (local.get $i)) \n"
"    (local.get $n)\n"
"  )\n"
"  (i32.store8 (i32.add (local.get $nptr) (local.get $n) ) (i32.const 0))\n"
"  (local.get $nptr)\n"
"  return\n"
")\n"
"\n"
"(func $wax::print (param $ptr i32)\n"
"  (local $len i32)\n"
"  (local.set $len (call $wax::str_len (local.get $ptr)))\n"
"  (call $wax::js::console.log (local.get $ptr) (local.get $len))\n"
")\n"
"\n"
"(func $wax::int2str (param $x i32) (result i32)\n"
"  (local $ptr i32)\n"
"  (local $rem i32)\n"
"  (local $isneg i32)\n"
"  (local $str i32)\n"
"\n"
"  (local.set $str (call $wax::alloca (i32.const 16)))\n"
"  (local.set $ptr (i32.add (local.get $str) (i32.const 15)))\n"
"  (i32.store8 (local.get $ptr) (i32.const 0))\n"
"  \n"
"  (local.set $isneg (i32.const 0))\n"
"  (if (i32.lt_s (local.get $x) (i32.const 0)) (then\n"
"    (local.set $isneg (i32.const 1))\n"
"    (local.set $x (i32.sub (i32.const 0) (local.get $x) ))\n"
"  ))\n"
"\n"
"  loop $digits\n"
"    (local.set $ptr (i32.sub (local.get $ptr) (i32.const 1)))\n"
"\n"
"    (local.set $rem (i32.rem_u (local.get $x) (i32.const 10)))\n"
"    (i32.store8 (local.get $ptr) (i32.add (local.get $rem) (i32.const 48)))\n"
"\n"
"    (local.set $x (i32.div_u (local.get $x) (i32.const 10)))\n"
"\n"
"    (if (i32.eqz (i32.eqz (local.get $x))) (then\n"
"      (br $digits)\n"
"    ))\n"
"  end\n"
"\n"
"  (if (local.get $isneg) (then\n"
"    (local.set $ptr (i32.sub (local.get $ptr) (i32.const 1)))\n"
"    (i32.store8 (local.get $ptr) (i32.const 45)) ;; '-'\n"
"  ))\n"
"\n"
"  (local.get $ptr)\n"
"  return\n"
")\n"
"\n"
"(func $wax::fint2str (param $x f32) (result i32)\n"
"  (local $ptr i32)\n"
"  (local $rem i32)\n"
"  (local $isneg i32)\n"
"  (local $str i32)\n"
"  (local.set $x (f32.trunc (local.get $x)))\n"
"\n"
"  (local.set $str (call $wax::alloca (i32.const 48)))\n"
"  (local.set $ptr (i32.add (local.get $str) (i32.const 47)))\n"
"  (i32.store8 (local.get $ptr) (i32.const 0))\n"
"  \n"
"  (if (f32.lt (local.get $x) (f32.const 0)) (then\n"
"    (local.set $isneg (i32.const 1))\n"
"    (local.set $x (f32.sub (f32.const 0) (local.get $x) ))\n"
"  ))\n"
"\n"
"  loop $digits\n"
"    (local.set $ptr (i32.sub (local.get $ptr) (i32.const 1)))\n"
"\n"
"    (local.set $rem (i32.trunc_f32_s (call $wax::fmod (local.get $x) (f32.const 10.0))))\n"
"    (i32.store8 (local.get $ptr) (i32.add (local.get $rem) (i32.const 48)))\n"
"\n"
"    (local.set $x (f32.div (local.get $x) (f32.const 10.0)))\n"
"\n"
"    (if (f32.gt (local.get $x) (f32.const 0.99999994) ) (then ;;nextafterf(1.00000001,0.0);\n"
"      (br $digits)\n"
"    ))\n"
"  end\n"
"\n"
"  (if (local.get $isneg) (then\n"
"    (local.set $ptr (i32.sub (local.get $ptr) (i32.const 1)))\n"
"    (i32.store8 (local.get $ptr) (i32.const 45)) ;; '-'\n"
"  ))\n"
"\n"
"  (local.get $ptr)\n"
"  return\n"
")\n"
"\n"
"\n"
"\n"
"\n"
"(func $wax::flt2str (param $x f32) (result i32)\n"
"  (local $ptr0 i32)\n"
"  (local $ptr i32)\n"
"  (local $rem i32)\n"
"  (local $isneg i32)\n"
"  (local $str i32)\n"
"\n"
"  (local.set $ptr0 (call $wax::fint2str (local.get $x)))\n"
"\n"
"  (if (f32.lt (local.get $x) (f32.const 0)) (then\n"
"    (local.set $x (f32.sub (f32.const 0.0) (local.get $x)))\n"
"  ))\n"
"  (local.set $x (f32.sub (local.get $x) (f32.trunc (local.get $x))))\n"
"  \n"
"  (local.set $str (call $wax::alloca (i32.const 16)))\n"
"  (i32.store8 (i32.sub (local.get $str) (i32.const 1)) (i32.const 46)  )\n"
"  (local.set $ptr (local.get $str))\n"
"  \n"
"  loop $digits\n"
"    \n"
"    (local.set $rem (i32.trunc_f32_s (f32.mul (local.get $x) (f32.const 10.0)) ))\n"
"    (i32.store8 (local.get $ptr) (i32.add (local.get $rem) (i32.const 48)))\n"
"\n"
"    (local.set $x (f32.sub (f32.mul (local.get $x) (f32.const 10.0)) (f32.convert_i32_s (local.get $rem))) )\n"
"\n"
"    (local.set $ptr (i32.add (local.get $ptr) (i32.const 1)))\n"
"\n"
"    (if (i32.and\n"
"      (f32.gt (local.get $x) (f32.const 1.1920928955078126e-7) ) ;; floating-point epsilon\n"
"      (i32.lt_s (i32.sub (local.get $ptr) (local.get $str)) (i32.const 15))\n"
"    )(then\n"
"      (br $digits)\n"
"    ))\n"
"  end\n"
"  (i32.store8 (local.get $ptr) (i32.const 0))\n"
"\n"
"  (local.get $ptr0)\n"
"  return\n"
"\n"
")\n"
"\n"
"(func $wax::str2int (param $s i32) (result i32)\n"
"  (local $x i32)\n"
"  (local $ptr i32)\n"
"  (local $d i32)\n"
"  (local $sign i32)\n"
"  (local.set $x (i32.const 0))\n"
"\n"
"  (local.set $ptr (local.get $s))\n"
"\n"
"  (local.set $sign (i32.const 1))\n"
"  (if (i32.eq (i32.load8_s (local.get $ptr) ) (i32.const 45) ) (then ;;'-'\n"
"    (local.set $sign (i32.const -1))\n"
"    (local.set $ptr (i32.add (local.get $ptr) (i32.const 1)))\n"
"  )(else(if (i32.eq (i32.load8_s (local.get $ptr) ) (i32.const 43) ) (then ;;'+'\n"
"    (local.set $ptr (i32.add (local.get $ptr) (i32.const 1))) ;;redundant\n"
"  ))))\n"
"\n"
"  loop $digits\n"
"    (local.set $d (i32.load8_s (local.get $ptr) ))\n"
"    (if (i32.or\n"
"      (i32.lt_s (local.get $d) (i32.const 48))\n"
"      (i32.gt_s (local.get $d) (i32.const 57))\n"
"    )(then\n"
"      (i32.mul (local.get $sign) (local.get $x))\n"
"      return\n"
"    ))\n"
"    \n"
"    (local.set $x (i32.mul (local.get $x) (i32.const 10)))\n"
"    (local.set $x (i32.add (local.get $x) (i32.sub (local.get $d) (i32.const 48))))\n"
"    \n"
"    (local.set $ptr (i32.add (local.get $ptr) (i32.const 1)))\n"
"    (br $digits)\n"
"  end\n"
"\n"
"  (i32.mul (local.get $sign) (local.get $x))\n"
"  return\n"
")\n"
"\n"
"(func $wax::str2flt (param $s i32) (result f32)\n"
"  (local $x f32)\n"
"  (local $ptr i32)\n"
"  (local $d i32)\n"
"  (local $sign f32)\n"
"  (local $mlt f32)\n"
"\n"
"  (local.set $x (f32.const 0.0))\n"
"\n"
"  (local.set $ptr (local.get $s))\n"
"\n"
"\n"
"  (local.set $sign (f32.const 1.0))\n"
"  (if (i32.eq (i32.load8_s (local.get $ptr) ) (i32.const 45) ) (then ;;'-'\n"
"    (local.set $sign (f32.const -1))\n"
"    (local.set $ptr (i32.add (local.get $ptr) (i32.const 1)))\n"
"  )(else(if (i32.eq (i32.load8_s (local.get $ptr) ) (i32.const 43) ) (then ;;'+'\n"
"    (local.set $ptr (i32.add (local.get $ptr) (i32.const 1))) ;;redundant\n"
"  ))))\n"
"\n"
"  block $out\n"
"  loop $digits\n"
"    (local.set $d (i32.load8_s (local.get $ptr) ))\n"
"    (if (i32.eq (local.get $d) (i32.const 46)) (then ;; '.'\n"
"      (local.set $ptr (i32.add (local.get $ptr) (i32.const 1)))\n"
"      (br $out)\n"
"    ))\n"
"    (if (i32.or\n"
"      (i32.lt_s (local.get $d) (i32.const 48))\n"
"      (i32.gt_s (local.get $d) (i32.const 57))\n"
"    )(then\n"
"      (f32.mul (local.get $sign) (local.get $x))\n"
"      return\n"
"    ))\n"
"    \n"
"    (local.set $x (f32.mul (local.get $x) (f32.const 10.0)))\n"
"    (local.set $x (f32.add (local.get $x) (f32.convert_i32_s (i32.sub (local.get $d) (i32.const 48)))))\n"
"    \n"
"    (local.set $ptr (i32.add (local.get $ptr) (i32.const 1)))\n"
"    (br $digits)\n"
"  end\n"
"  end\n"
"\n"
"  (local.set $mlt (f32.const 0.1))\n"
"  loop $fracs\n"
"    (local.set $d (i32.load8_s (local.get $ptr) ))\n"
"\n"
"    (if (i32.or\n"
"      (i32.lt_s (local.get $d) (i32.const 48))\n"
"      (i32.gt_s (local.get $d) (i32.const 57))\n"
"    )(then\n"
"      (f32.mul (local.get $sign) (local.get $x))\n"
"      return\n"
"    ))\n"
"    (local.set $x (f32.add\n"
"      (local.get $x)\n"
"      (f32.mul (f32.convert_i32_s (i32.sub (local.get $d) (i32.const 48))) (local.get $mlt))\n"
"    ))\n"
"    (local.set $mlt (f32.mul (local.get $mlt) (f32.const 0.1)))\n"
"    \n"
"    (local.set $ptr (i32.add (local.get $ptr) (i32.const 1)))\n"
"\n"
"    (br $fracs)\n"
"  end\n"
"\n"
"  (f32.mul (local.get $sign) (local.get $x))\n"
"  return\n"
")\n";
const char* TEXT_std_malloc_wat = ";;========================================================;;\n"
";;     BASELINE MALLOC WITH HANDWRITTEN WEBASSEMBLY       ;;\n"
";;========================================================;;\n"
";; 32-bit implicit-free-list first-fit baseline malloc    ;;\n"
";;--------------------------------------------------------;;\n"
"\n"
";; IMPLICIT FREE LIST:\n"
";; Worse utilization and throughput than explicit/segregated, but easier\n"
";; to implement :P\n"
";;\n"
";; HEAP LO                                                         HEAP HI\n"
";; +---------------------+---------------------+...+---------------------+\n"
";; | HDR | PAYLOAD | FTR | HDR | PAYLOAD | FTR |...+ HDR | PAYLOAD | FTR |\n"
";; +----------^----------+---------------------+...+---------------------+\n"
";;            |_ i.e. user data\n"
";;           \n"
";; LAYOUT OF A BLOCK:\n"
";; Since memory is aligned to multiple of 4 bytes, the last two bits of\n"
";; payload_size is redundant. Therefore the last bit of header is used to\n"
";; store the is_free flag.\n"
";; \n"
";; |---- HEADER (4b)----\n"
";; |    ,--payload size (x4)--.     ,-is free?\n"
";; | 0b . . . . . . . . . . . . 0  0\n"
";; |------ PAYLOAD -----\n"
";; |\n"
";; |  user data (N x 4b)\n"
";; |\n"
";; |---- FOOTER (4b)---- (duplicate of header)\n"
";; |    ,--payload size (x4)--.     ,-is free?\n"
";; | 0b . . . . . . . . . . . . 0  0\n"
";; |--------------------\n"
";;\n"
";; FORMULAS:\n"
";; (these formulas are used throughout the code, so they're listed here\n"
";; instead of explained each time encountered)\n"
";;\n"
";; payload_size = block_size - (header_size + footer_size) = block_size - 8\n"
";; \n"
";; payload_pointer = header_pointer + header_size = header_pointer + 4\n"
";;\n"
";; footer_pointer = header_pointer + header_size + payload_size\n"
";;                = (header_pointer + payload_size) + 4\n"
";;\n"
";; next_header_pointer = footer_pointer + footer_size = footer_pointer + 4\n"
";;\n"
";; prev_footer_pointer = header_pointer - footer_size = header_pointer - 4\n"
"\n"
"(memory $wax::mem 1)                                ;; start with 1 page (64K)\n"
"(export \"mem\" (memory $wax::mem))\n"
";;// (global $wax::min_addr (mut i32) (i32.const 0))  ;; set by wax compiler depending on data section size\n"
"(global $wax::max_addr (mut i32) (i32.const 65536)) ;; initial heap size (64K)\n"
"(global $wax::heap_did_init (mut i32) (i32.const 0))     ;; init() called?\n"
"\n"
";; helpers to pack/unpack payload_size/is_free from header/footer\n"
";; by masking out bits\n"
"\n"
";; read payload_size from header/footer given pointer to header/footer\n"
"(func $wax::hdr_get_size (param $ptr i32) (result i32)\n"
"  (i32.and (i32.load (local.get $ptr)) (i32.const 0xFFFFFFFC))\n"
")\n"
";; read is_free from header/footer\n"
"(func $wax::hdr_get_free (param $ptr i32) (result i32)\n"
"  (i32.and (i32.load (local.get $ptr)) (i32.const 0x00000001))\n"
")\n"
";; write payload_size to header/footer\n"
"(func $wax::hdr_set_size (param $ptr i32) (param $n i32) \n"
"  (i32.store (local.get $ptr) (i32.or\n"
"    (i32.and (i32.load (local.get $ptr)) (i32.const 0x00000003))\n"
"    (local.get $n)\n"
"  ))\n"
")\n"
";; write is_free to header/footer\n"
"(func $wax::hdr_set_free (param $ptr i32) (param $n i32)\n"
"  (i32.store (local.get $ptr) (i32.or\n"
"    (i32.and (i32.load (local.get $ptr)) (i32.const 0xFFFFFFFE))\n"
"    (local.get $n)\n"
"  ))\n"
")\n"
";; align memory by 4 bytes\n"
"(func $wax::align4 (param $x i32) (result i32)\n"
"  (i32.and\n"
"    (i32.add (local.get $x) (i32.const 3))\n"
"    (i32.const -4)\n"
"  )\n"
")\n"
"\n"
";; initialize heap\n"
";; make the whole heap a big free block\n"
";; - automatically invoked by first malloc() call\n"
";; - can be manually called to nuke the whole heap\n"
"(func $wax::init_heap\n"
"  (i32.store (i32.const 0) (global.get $wax::min_addr) )\n"
"  ;; write payload_size to header and footer\n"
"  (call $wax::hdr_set_size (global.get $wax::min_addr) \n"
"    (i32.sub (i32.sub (global.get $wax::max_addr) (global.get $wax::min_addr)) (i32.const 8))\n"
"  )\n"
"  (call $wax::hdr_set_size (i32.sub (global.get $wax::max_addr) (i32.const 4))\n"
"    (i32.sub (i32.sub (global.get $wax::max_addr) (global.get $wax::min_addr)) (i32.const 8))\n"
"  )\n"
"  ;; write is_free to header and footer\n"
"  (call $wax::hdr_set_free (global.get $wax::min_addr) (i32.const 1))\n"
"  (call $wax::hdr_set_free (i32.sub (global.get $wax::max_addr) (i32.const 4)) (i32.const 1))\n"
"\n"
"  ;; set flag to tell malloc() that we've already called init()\n"
"  (global.set $wax::heap_did_init (i32.const 1)) \n"
")\n"
"\n"
";; extend (grow) the heap (to accomodate more blocks)\n"
";; parameter: number of pages (64K) to grow\n"
";; - automatically invoked by malloc() when current heap has insufficient free space\n"
";; - can be manually called to get more space in advance\n"
"(func $wax::extend (param $n_pages i32)\n"
"  (local $n_bytes i32)\n"
"  (local $ftr i32)\n"
"  (local $prev_ftr i32)\n"
"  (local $prev_hdr i32)\n"
"  (local $prev_size i32)\n"
"\n"
"  (local.set $prev_ftr (i32.sub (global.get $wax::max_addr) (i32.const 4)) )\n"
"\n"
"  ;; compute number of bytes from page count (1page = 64K = 65536bytes)\n"
"  (local.set $n_bytes (i32.mul (local.get $n_pages) (i32.const 65536)))\n"
"\n"
"  ;; system call to grow memory (`drop` discards the (useless) return value of memory.grow)\n"
"  (drop (memory.grow (local.get $n_pages) ))\n"
"\n"
"  ;; make the newly acquired memory a big free block\n"
"  (call $wax::hdr_set_size (global.get $wax::max_addr) (i32.sub (local.get $n_bytes) (i32.const 8)))\n"
"  (call $wax::hdr_set_free (global.get $wax::max_addr) (i32.const 1))\n"
"\n"
"  (global.set $wax::max_addr (i32.add (global.get $wax::max_addr) (local.get $n_bytes) ))\n"
"  (local.set $ftr (i32.sub (global.get $wax::max_addr) (i32.const 4)))\n"
"\n"
"  (call $wax::hdr_set_size (local.get $ftr)\n"
"    (i32.sub (local.get $n_bytes) (i32.const 8))\n"
"  )\n"
"  (call $wax::hdr_set_free (local.get $ftr) (i32.const 1))\n"
"\n"
"  ;; see if we can join the new block with the last block of the old heap\n"
"  (if (i32.eqz (call $wax::hdr_get_free (local.get $prev_ftr)))(then)(else\n"
"\n"
"    ;; the last block is free, join it.\n"
"    (local.set $prev_size (call $wax::hdr_get_size (local.get $prev_ftr)))\n"
"    (local.set $prev_hdr\n"
"      (i32.sub (i32.sub (local.get $prev_ftr) (local.get $prev_size)) (i32.const 4))\n"
"    )\n"
"    (call $wax::hdr_set_size (local.get $prev_hdr)\n"
"      (i32.add (local.get $prev_size) (local.get $n_bytes) )\n"
"    )\n"
"    (call $wax::hdr_set_size (local.get $ftr)\n"
"      (i32.add (local.get $prev_size) (local.get $n_bytes) )\n"
"    )\n"
"  ))\n"
"\n"
")\n"
"\n"
";; find a free block that fit the request number of bytes\n"
";; modifies the heap once a candidate is found\n"
";; first-fit: not the best policy, but the simplest\n"
"(func $wax::find (param $n_bytes i32) (result i32)\n"
"  (local $ptr i32)\n"
"  (local $size i32)\n"
"  (local $is_free i32)\n"
"  (local $pay_ptr i32)\n"
"  (local $rest i32)\n"
"\n"
"  ;; loop through all blocks\n"
"  (local.set $ptr (global.get $wax::min_addr))\n"
"  loop $search\n"
"    ;; we reached the end of heap and haven't found anything, return NULL\n"
"    (if (i32.lt_u (local.get $ptr) (global.get $wax::max_addr))(then)(else\n"
"      (i32.const 0)\n"
"      return\n"
"    ))\n"
"\n"
"    ;; read info about current block\n"
"    (local.set $size    (call $wax::hdr_get_size (local.get $ptr)))\n"
"    (local.set $is_free (call $wax::hdr_get_free (local.get $ptr)))\n"
"    (local.set $pay_ptr (i32.add (local.get $ptr) (i32.const 4) ))\n"
"\n"
"    ;; check if the current block is free\n"
"    (if (i32.eq (local.get $is_free) (i32.const 1))(then\n"
"\n"
"      ;; it's free, but too small, move on\n"
"      (if (i32.gt_u (local.get $n_bytes) (local.get $size))(then\n"
"        (local.set $ptr (i32.add (local.get $ptr) (i32.add (local.get $size) (i32.const 8))))\n"
"        (br $search)\n"
"\n"
"      ;; it's free, and large enough to be split into two blocks\n"
"      )(else(if (i32.lt_u (local.get $n_bytes) (i32.sub (local.get $size) (i32.const 8)))(then\n"
"        ;; OLD HEAP\n"
"        ;; ...+-------------------------------------------+...\n"
"        ;; ...| HDR |              FREE             | FTR |...\n"
"        ;; ...+-------------------------------------------+...\n"
"        ;; NEW HEAP\n"
"        ;; ...+---------------------+---------------------+...\n"
"        ;; ...| HDR | ALLOC   | FTR | HDR |  FREE   | FTR |...\n"
"        ;; ...+---------------------+---------------------+...\n"
"\n"
"        ;; size of the remaining half\n"
"        (local.set $rest (i32.sub (i32.sub (local.get $size) (local.get $n_bytes) ) (i32.const 8)))\n"
"\n"
"        ;; update headers and footers to reflect the change (see FORMULAS)\n"
"\n"
"        (call $wax::hdr_set_size (local.get $ptr) (local.get $n_bytes))\n"
"        (call $wax::hdr_set_free (local.get $ptr) (i32.const 0))\n"
"\n"
"        (call $wax::hdr_set_size (i32.add (i32.add (local.get $ptr) (local.get $n_bytes)) (i32.const 4))\n"
"          (local.get $n_bytes)\n"
"        )\n"
"        (call $wax::hdr_set_free (i32.add (i32.add (local.get $ptr) (local.get $n_bytes)) (i32.const 4))\n"
"          (i32.const 0)\n"
"        )\n"
"        (call $wax::hdr_set_size (i32.add (i32.add (local.get $ptr) (local.get $n_bytes)) (i32.const 8))\n"
"          (local.get $rest)\n"
"        )\n"
"        (call $wax::hdr_set_free (i32.add (i32.add (local.get $ptr) (local.get $n_bytes)) (i32.const 8))\n"
"          (i32.const 1)\n"
"        )\n"
"        (call $wax::hdr_set_size (i32.add (i32.add (local.get $ptr) (local.get $size)) (i32.const 4))\n"
"          (local.get $rest)\n"
"        )\n"
"\n"
"        (local.get $pay_ptr)\n"
"        return\n"
"\n"
"      )(else\n"
"        ;; the block is free, but not large enough to be split into two blocks \n"
"        ;; we return the whole block as one\n"
"        (call $wax::hdr_set_free (local.get $ptr) (i32.const 0))\n"
"        (call $wax::hdr_set_free (i32.add (i32.add (local.get $ptr) (local.get $size)) (i32.const 4))\n"
"          (i32.const 0)\n"
"        )\n"
"        (local.get $pay_ptr)\n"
"        return\n"
"      ))))\n"
"    )(else\n"
"      ;; the block is not free, we move on to the next block\n"
"      (local.set $ptr (i32.add (local.get $ptr) (i32.add (local.get $size) (i32.const 8))))\n"
"      (br $search)\n"
"    ))\n"
"  end\n"
"\n"
"  ;; theoratically we will not reach here\n"
"  ;; return NULL\n"
"  (i32.const 0)\n"
")\n"
"\n"
"\n"
";; malloc - allocate the requested number of bytes on the heap\n"
";; returns a pointer to the block of memory allocated\n"
";; returns NULL (0) when OOM\n"
";; if heap is not large enough, grows it via extend()\n"
"(func $wax::malloc (param $n_bytes i32) (result i32)\n"
"  (local $ptr i32)\n"
"  (local $n_pages i32)\n"
"\n"
"  ;; call init() if we haven't done so yet\n"
"  (if (i32.eqz (global.get $wax::heap_did_init)) (then\n"
"    (call $wax::init_heap)\n"
"  ))\n"
"\n"
"  ;; payload size is aligned to multiple of 4\n"
"  (local.set $n_bytes (call $wax::align4 (local.get $n_bytes)))\n"
"\n"
"  ;; attempt allocation\n"
"  (local.set $ptr (call $wax::find (local.get $n_bytes)) )\n"
"\n"
"  ;; NULL -> OOM -> extend heap\n"
"  (if (i32.eqz (local.get $ptr))(then\n"
"    ;; compute # of pages from # of bytes, rounding up\n"
"    (local.set $n_pages\n"
"      (i32.div_u \n"
"        (i32.add (local.get $n_bytes) (i32.const 65527) )\n"
"        (i32.const 65528)\n"
"      )\n"
"    )\n"
"    (call $wax::extend (local.get $n_pages))\n"
"\n"
"    ;; try again\n"
"    (local.set $ptr (call $wax::find (local.get $n_bytes)) )\n"
"  ))\n"
"  (local.get $ptr)\n"
")\n"
"\n"
";; free - free an allocated block given a pointer to it\n"
"(func $wax::free (param $ptr i32)\n"
"  (local $hdr i32)\n"
"  (local $ftr i32)\n"
"  (local $size i32)\n"
"  (local $prev_hdr i32)\n"
"  (local $prev_ftr i32)\n"
"  (local $prev_size i32)\n"
"  (local $prev_free i32)\n"
"  (local $next_hdr i32)\n"
"  (local $next_ftr i32)\n"
"  (local $next_size i32)\n"
"  (local $next_free i32)\n"
"  \n"
"  ;; step I: mark the block as free\n"
"\n"
"  (local.set $hdr (i32.sub (local.get $ptr) (i32.const 4)))\n"
"  (local.set $size (call $wax::hdr_get_size (local.get $hdr)))\n"
"  (local.set $ftr (i32.add (i32.add (local.get $hdr) (local.get $size)) (i32.const 4)))\n"
"\n"
"  (call $wax::hdr_set_free (local.get $hdr) (i32.const 1))\n"
"  (call $wax::hdr_set_free (local.get $ftr) (i32.const 1))\n"
"\n"
"  ;; step II: try coalasce\n"
"\n"
"  ;; coalasce with previous block\n"
"\n"
"  ;; check that we're not already the first block\n"
"  (if (i32.eq (local.get $hdr) (global.get $wax::min_addr)) (then)(else\n"
"\n"
"    ;; read info about previous block\n"
"    (local.set $prev_ftr (i32.sub (local.get $hdr) (i32.const 4)))\n"
"    (local.set $prev_size (call $wax::hdr_get_size (local.get $prev_ftr)))\n"
"    (local.set $prev_hdr \n"
"      (i32.sub (i32.sub (local.get $prev_ftr) (local.get $prev_size)) (i32.const 4))\n"
"    )\n"
"\n"
"    ;; check if previous block is free -> merge them\n"
"    (if (i32.eqz (call $wax::hdr_get_free (local.get $prev_ftr))) (then) (else\n"
"      (local.set $size (i32.add (i32.add (local.get $size) (local.get $prev_size)) (i32.const 8)))\n"
"      (call $wax::hdr_set_size (local.get $prev_hdr) (local.get $size))\n"
"      (call $wax::hdr_set_size (local.get $ftr) (local.get $size))\n"
"\n"
"      ;; set current header pointer to previous header\n"
"      (local.set $hdr (local.get $prev_hdr))\n"
"    ))\n"
"  ))\n"
"\n"
"  ;; coalasce with next block\n"
"\n"
"  (local.set $next_hdr (i32.add (local.get $ftr) (i32.const 4)))\n"
"\n"
"  ;; check that we're not already the last block\n"
"  (if (i32.eq (local.get $next_hdr) (global.get $wax::max_addr)) (then)(else\n"
"    \n"
"    ;; read info about next block\n"
"    (local.set $next_size (call $wax::hdr_get_size (local.get $next_hdr)))\n"
"    (local.set $next_ftr \n"
"      (i32.add (i32.add (local.get $next_hdr) (local.get $next_size)) (i32.const 4))\n"
"    )\n"
"\n"
"    ;; check if next block is free -> merge them\n"
"    (if (i32.eqz (call $wax::hdr_get_free (local.get $next_hdr))) (then) (else\n"
"      (local.set $size (i32.add (i32.add (local.get $size) (local.get $next_size)) (i32.const 8)))\n"
"      (call $wax::hdr_set_size (local.get $hdr) (local.get $size))\n"
"      (call $wax::hdr_set_size (local.get $next_ftr) (local.get $size))\n"
"    ))\n"
"\n"
"  ))\n"
"\n"
")\n"
";; copy a block of memory over, from src pointer to dst pointer\n"
";; WebAssembly seems to be planning to support memory.copy\n"
";; until then, this function uses a loop and i32.store8/load8\n"
"(func $wax::memcpy (param $dst i32) (param $src i32) (param $n_bytes i32)\n"
"  (local $ptr i32)\n"
"  (local $offset i32)\n"
"  (local $data i32)\n"
"\n"
"  (if (i32.eqz (local.get $n_bytes))(then\n"
"    return\n"
"  ))\n"
"\n"
"  (local.set $offset (i32.const 0))\n"
"\n"
"  loop $cpy\n"
"    (local.set $data (i32.load8_u (i32.add (local.get $src) (local.get $offset))))\n"
"    (i32.store8 (i32.add (local.get $dst) (local.get $offset)) (local.get $data))\n"
"\n"
"    (local.set $offset (i32.add (local.get $offset) (i32.const 1)))\n"
"    (br_if $cpy (i32.lt_u (local.get $offset) (local.get $n_bytes)))\n"
"  end\n"
")\n"
"\n"
";; reallocate memory to new size\n"
";; currently does not support contraction\n"
";; nothing will happen if n_bytes is smaller than current payload size\n"
"(func $wax::realloc (param $ptr i32) (param $n_bytes i32) (result i32)\n"
"  (local $hdr i32)\n"
"  (local $next_hdr i32)\n"
"  (local $next_ftr i32)\n"
"  (local $next_size i32)\n"
"  (local $ftr i32)\n"
"  (local $size i32)\n"
"  (local $rest_hdr i32)\n"
"  (local $rest_size i32)\n"
"  (local $new_ptr i32)\n"
"\n"
"  (local.set $hdr (i32.sub (local.get $ptr) (i32.const 4)))\n"
"  (local.set $size (call $wax::hdr_get_size (local.get $hdr)))\n"
"\n"
"  (if (i32.gt_u (local.get $n_bytes) (local.get $size)) (then) (else\n"
"    (local.get $ptr)\n"
"    return\n"
"  ))\n"
"\n"
"  ;; payload size is aligned to multiple of 4\n"
"  (local.set $n_bytes (call $wax::align4 (local.get $n_bytes)))\n"
"\n"
"  (local.set $next_hdr (i32.add (i32.add (local.get $hdr) (local.get $size)) (i32.const 8)))\n"
"\n"
"  ;; Method I: try to expand the current block\n"
"\n"
"  ;; check that we're not already the last block\n"
"  (if (i32.lt_u (local.get $next_hdr) (global.get $wax::max_addr) )(then\n"
"    (if (call $wax::hdr_get_free (local.get $next_hdr)) (then\n"
"\n"
"      (local.set $next_size (call $wax::hdr_get_size (local.get $next_hdr)))\n"
"      (local.set $rest_size (i32.sub \n"
"        (local.get $next_size)\n"
"        (i32.sub (local.get $n_bytes) (local.get $size))\n"
"      ))\n"
"      (local.set $next_ftr (i32.add (i32.add (local.get $next_hdr) (local.get $next_size)) (i32.const 4)))\n"
"\n"
"      ;; next block is big enough to be split into two\n"
"      (if (i32.gt_s (local.get $rest_size) (i32.const 0) ) (then\n"
"        \n"
"        (call $wax::hdr_set_size (local.get $hdr) (local.get $n_bytes))\n"
"        \n"
"        (local.set $ftr (i32.add (i32.add (local.get $hdr) (local.get $n_bytes) ) (i32.const 4)))\n"
"        (call $wax::hdr_set_size (local.get $ftr) (local.get $n_bytes))\n"
"        (call $wax::hdr_set_free (local.get $ftr) (i32.const 0))\n"
"\n"
"        (local.set $rest_hdr (i32.add (local.get $ftr) (i32.const 4) ))\n"
"        (call $wax::hdr_set_size (local.get $rest_hdr) (local.get $rest_size))\n"
"        (call $wax::hdr_set_free (local.get $rest_hdr) (i32.const 1))\n"
"\n"
"        (call $wax::hdr_set_size (local.get $next_ftr) (local.get $rest_size))\n"
"        (call $wax::hdr_set_free (local.get $next_ftr) (i32.const 1))\n"
"\n"
"        (local.get $ptr)\n"
"        return\n"
"\n"
"      ;; next block is not big enough to be split, but is\n"
"      ;; big enough to merge with the current one into one\n"
"      )(else (if (i32.gt_s (local.get $rest_size) (i32.const -9) ) (then\n"
"      \n"
"        (local.set $size (i32.add (i32.add (local.get $size) (i32.const 8) ) (local.get $next_size)))\n"
"        (call $wax::hdr_set_size (local.get $hdr) (local.get $size))\n"
"        (call $wax::hdr_set_size (local.get $next_ftr) (local.get $size))\n"
"        (call $wax::hdr_set_free (local.get $next_ftr) (i32.const 0))\n"
"\n"
"        (local.get $ptr)\n"
"        return\n"
"      ))))\n"
"\n"
"    ))\n"
"  ))\n"
"\n"
"  ;; Method II: allocate a new block and copy over\n"
"\n"
"  (local.set $new_ptr (call $wax::malloc (local.get $n_bytes)))\n"
"  (call $wax::memcpy (local.get $new_ptr) (local.get $ptr) (local.get $size))\n"
"  (call $wax::free (local.get $ptr))\n"
"  (local.get $new_ptr)\n"
"\n"
")\n"
"\n"
"(func $wax::calloc (param $n_bytes i32) (result i32)\n"
"  (local $ptr i32)\n"
"  (local $offset i32)\n"
"  (local.set $ptr (call $wax::malloc (local.get $n_bytes)))\n"
"  (local.set $offset (i32.const 0))\n"
"  loop $zero\n"
"    (if (i32.lt_u (local.get $offset) (local.get $n_bytes)) (then\n"
"      (i32.store8 (i32.add (local.get $offset) (local.get $ptr) ) (i32.const 0))\n"
"      (local.set $offset (i32.add (local.get $offset) (i32.const 1)))\n"
"      (br $zero)\n"
"    ))\n"
"  end\n"
"  (local.get $ptr)\n"
"  return\n"
")\n"
"\n"
"(func $wax::memmove (param $dst i32) (param $src i32) (param $n_bytes i32)\n"
"  (local $ptr i32)\n"
"  (local $offset i32)\n"
"  (local $data i32)\n"
"\n"
"  (if (i32.eqz (local.get $n_bytes))(then\n"
"    return\n"
"  ))\n"
"  \n"
"  (if (i32.gt_u (local.get $dst) (local.get $src)) (then\n"
"    (local.set $offset (i32.sub (local.get $n_bytes) (i32.const 1)))\n"
"    loop $cpy_rev\n"
"      (local.set $data (i32.load8_u (i32.add (local.get $src) (local.get $offset))))\n"
"      (i32.store8 (i32.add (local.get $dst) (local.get $offset)) (local.get $data))\n"
"\n"
"      (local.set $offset (i32.sub (local.get $offset) (i32.const 1)))\n"
"      (br_if $cpy_rev (i32.gt_s (local.get $offset) (i32.const -1)))\n"
"    end\n"
"  \n"
"  )(else\n"
"    (local.set $offset (i32.const 0))\n"
"    loop $cpy\n"
"      (local.set $data (i32.load8_u (i32.add (local.get $src) (local.get $offset))))\n"
"      (i32.store8 (i32.add (local.get $dst) (local.get $offset)) (local.get $data))\n"
"\n"
"      (local.set $offset (i32.add (local.get $offset) (i32.const 1)))\n"
"      (br_if $cpy (i32.lt_u (local.get $offset) (local.get $n_bytes)))\n"
"    end\n"
"  ))\n"
")\n"
"\n";
const char* TEXT_std_map_wat = ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
";;                                  ;;\n"
";;                                  ;;\n"
";;                MAP               ;;\n"
";;                                  ;;\n"
";;                                  ;;\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
";; adapted from https://github.com/LingDong-/wasm-fun\n"
"\n"
";;   Hash table (separate chaining with linked lists)\n"
";;   similar to C++ map<T,T>.\n"
";;\n"
";;   Entire key is stored in map node; val is 32 bit int/float/pointer\n"
";;\n"
";;   Functions involving keys have two versions, *_i and *_h.\n"
";;   _i takes an i32 as key directly (for simple small keys), \n"
";;   while _h versions read the key from the heap given a \n"
";;   pointer and a byte count (for larger keys)\n"
";;\n"
";;   +-----------+\n"
";;   |num_buckets|          ,----------------------.\n"
";;   |-----------|        +-|-------------------+  |  +---------------------+\n"
";;   | bucket 0  |------->|next|key_size|key|val|  `->|next|key_size|key|val|\n"
";;   |-----------|        +---------------------+     +---------------------+\n"
";;   | bucket 1  |\n"
";;   |-----------|        +---------------------+\n"
";;   | bucket 2  |------->|next|key_size|key|val|\n"
";;   |-----------|        +---------------------+\n"
";;   | ......... |\n"
"\n"
"\n"
";; struct map{\n"
";;   int num_buckets;\n"
";;   int length;\n"
";;   mapnode* bucket0;\n"
";;   mapnode* bucket1;\n"
";;   mapnode* bucket2;\n"
";;   ...\n"
";; }\n"
";; struct mapnode{\n"
";;   mapnode* next;\n"
";;   int key_size;\n"
";;   key_t key;\n"
";;   int val;\n"
";; }\n"
"\n"
";; (internal) getters and setters for map struct\n"
"\n"
"(func $wax::_map_get_num_buckets (param $m i32) (result i32)\n"
"  (i32.load (local.get $m))\n"
")\n"
"(func $wax::_map_set_num_buckets (param $m i32) (param $num_buckets i32)\n"
"  (i32.store (local.get $m) (local.get $num_buckets))\n"
")\n"
"(func $wax::map_length (param $m i32) (result i32)\n"
"  (i32.load (i32.add (local.get $m) (i32.const 4)))\n"
")\n"
"(func $wax::_map_inc_length (param $m i32) (param $dx i32)\n"
"  (local $l i32)\n"
"  (local $o i32)\n"
"  (local.set $o (i32.add (local.get $m) (i32.const 4)))\n"
"  (local.set $l (i32.load (local.get $o)))\n"
"  (i32.store (local.get $o) (i32.add (local.get $l) (local.get $dx)))\n"
")\n"
"(func $wax::_map_get_bucket (param $m i32) (param $i i32) (result i32)\n"
"  (i32.load (i32.add \n"
"    (i32.add (local.get $m) (i32.const 8)) \n"
"    (i32.mul (local.get $i) (i32.const 4))\n"
"  ))\n"
")\n"
"(func $wax::_map_set_bucket (param $m i32) (param $i i32) (param $ptr i32)\n"
"  (i32.store (i32.add \n"
"    (i32.add (local.get $m) (i32.const 8)) \n"
"    (i32.mul (local.get $i) (i32.const 4))\n"
"  ) (local.get $ptr) )\n"
")\n"
"\n"
";; (internal) getters and setters for map node struct\n"
"\n"
"(func $wax::_mapnode_get_next (param $m i32) (result i32)\n"
"  (i32.load (local.get $m))\n"
")\n"
"(func $wax::_mapnode_get_key_size (param $m i32) (result i32)\n"
"  (i32.load (i32.add (local.get $m) (i32.const 4)))\n"
")\n"
"(func $wax::_mapnode_get_key_ptr (param $m i32) (result i32)\n"
"  (i32.add (local.get $m) (i32.const 8))\n"
")\n"
"(func $wax::_mapnode_get_val_ptr (param $m i32) (result i32)\n"
"  (local $key_size i32)\n"
"  (local.set $key_size (call $wax::_mapnode_get_key_size (local.get $m)))\n"
"  (i32.add (i32.add (local.get $m) (i32.const 8)) (local.get $key_size))\n"
")\n"
"\n"
"(func $wax::_mapnode_set_next (param $m i32) (param $v i32)\n"
"  (i32.store (local.get $m) (local.get $v))\n"
")\n"
"(func $wax::_mapnode_set_key_size (param $m i32) (param $v i32)\n"
"  (i32.store (i32.add (local.get $m) (i32.const 4)) (local.get $v))\n"
")\n"
"\n"
"(func $wax::_mapnode_set_key_h (param $m i32) (param $key_ptr i32) (param $key_size i32)\n"
"  (local $ptr i32)\n"
"  (local $i i32)\n"
"  (local.set $ptr (call $wax::_mapnode_get_key_ptr (local.get $m)))\n"
"  loop $loop_mapnode_set_key_h\n"
"    (i32.store8 \n"
"      (i32.add (local.get $ptr) (local.get $i))\n"
"      (i32.load8_u (i32.add (local.get $key_ptr) (local.get $i)))\n"
"    )\n"
"    (local.set $i (i32.add (local.get $i) (i32.const 1)))\n"
"    (br_if $loop_mapnode_set_key_h (i32.lt_u (local.get $i) (local.get $key_size) ))\n"
"  end\n"
")\n"
"(func $wax::_mapnode_set_key_i (param $m i32) (param $key i32)\n"
"  (i32.store\n"
"    (call $wax::_mapnode_get_key_ptr (local.get $m))\n"
"    (local.get $key) \n"
"  )\n"
")\n"
"\n"
";; Hash functions\n"
"\n"
";; hash an integer with SHR3\n"
"(func $wax::_map_hash_i (param $num_buckets i32) (param $key i32) (result i32)\n"
"  (local.set $key (i32.xor (local.get $key) (i32.shl   (local.get $key) (i32.const 17))))\n"
"  (local.set $key (i32.xor (local.get $key) (i32.shr_u (local.get $key) (i32.const 13))))\n"
"  (local.set $key (i32.xor (local.get $key) (i32.shl   (local.get $key) (i32.const 5 ))))\n"
"  (i32.rem_u (local.get $key) (local.get $num_buckets))\n"
")\n"
"\n"
";; hash a sequence of bytes by xor'ing them into an integer and calling _map_hash_i\n"
"(func $wax::_map_hash_h (param $num_buckets i32) (param $key_ptr i32) (param $key_size i32) (result i32)\n"
"  (local $key i32)\n"
"  (local $i i32)\n"
"  (local $byte i32)\n"
"\n"
"  (local.set $i (i32.const 0))\n"
"  loop $loop_map_hash_h\n"
"    (local.set $byte (i32.load8_u (i32.add (local.get $key_ptr) (local.get $i))))\n"
"    \n"
"    (local.set $key\n"
"      (i32.xor (local.get $key) \n"
"        (i32.shl (local.get $byte) (i32.mul (i32.const 8) (i32.rem_u (local.get $i) (i32.const 4))))\n"
"      )\n"
"    )\n"
"    (local.set $i (i32.add (local.get $i) (i32.const 1)))\n"
"    (br_if $loop_map_hash_h (i32.lt_u (local.get $i) (local.get $key_size) ))\n"
"  end\n"
"\n"
"  (call $wax::_map_hash_i (local.get $num_buckets) (local.get $key))\n"
")\n"
"\n"
";; initialize a new map, given number of buckets\n"
";; returns a pointer to the map\n"
"(func $wax::map_new (param $num_buckets i32) (result i32)\n"
"  (local $m i32)\n"
"  (local $i i32)\n"
"  (local.set $m (call $wax::malloc (i32.add (i32.mul (local.get $num_buckets) (i32.const 4)) (i32.const 8)) ))\n"
"  (call $wax::_map_set_num_buckets (local.get $m) (local.get $num_buckets))\n"
"\n"
"  (local.set $i (i32.const 0))\n"
"  loop $loop_map_new_clear\n"
"    (call $wax::_map_set_bucket (local.get $m) (local.get $i) (i32.const 0))\n"
"    (local.set $i (i32.add (local.get $i) (i32.const 1)))\n"
"    (br_if $loop_map_new_clear (i32.lt_u (local.get $i) (local.get $num_buckets) ))\n"
"  end\n"
"  (local.get $m)\n"
")\n"
"\n"
";; compare the key stored in a node agianst a key on the heap\n"
"(func $wax::_map_cmp_key_h (param $node i32) (param $key_ptr i32) (param $key_size i32) (result i32)\n"
"  (local $key_ptr0 i32)\n"
"  (local $key_size0 i32)\n"
"  (local $i i32)\n"
"  (local.set $key_ptr0 (call $wax::_mapnode_get_key_ptr (local.get $node)))\n"
"  (local.set $key_size0 (call $wax::_mapnode_get_key_size (local.get $node)))\n"
"  (if (i32.eq (local.get $key_size0) (local.get $key_size))(then\n"
"    (local.set $i (i32.const 0))\n"
"    loop $loop_map_cmp_key_h\n"
"\n"
"      (if (i32.eq \n"
"        (i32.load8_u (i32.add (local.get $key_ptr0) (local.get $i)))\n"
"        (i32.load8_u (i32.add (local.get $key_ptr ) (local.get $i)))\n"
"      )(then)(else\n"
"        (i32.const 0)\n"
"        return\n"
"      ))\n"
"      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n"
"      (br_if $loop_map_cmp_key_h (i32.lt_u (local.get $i) (local.get $key_size) ))\n"
"    end\n"
"    (i32.const 1)\n"
"    return\n"
"  ))\n"
"  (i32.const 0)\n"
"  return\n"
")\n"
"\n"
";; compare the key stored in a node agianst a key passed directly as i32 argument\n"
"(func $wax::_map_cmp_key_i (param $node i32) (param $key i32) (result i32)\n"
"  (local $key_ptr0 i32)\n"
"  (local $key_size0 i32)\n"
"  (local.set $key_ptr0 (call $wax::_mapnode_get_key_ptr (local.get $node)))\n"
"  (local.set $key_size0 (call $wax::_mapnode_get_key_size (local.get $node)))\n"
"\n"
"  (if (i32.eq (local.get $key_size0) (i32.const 4))(then\n"
"    (i32.eq (i32.load (local.get $key_ptr0))  (local.get $key) )\n"
"    return\n"
"  ))\n"
"  (i32.const 0)\n"
"  return\n"
")\n"
"\n"
";; insert a new entry to the map, taking a key stored on the heap\n"
";; m : the map\n"
";; key_ptr: pointer to the key on the heap\n"
";; key_size: size of the key in bytes\n"
";; returns pointer to the value inserted in the map for the user to write at\n"
"\n"
"(func $wax::map_set_h (param $m i32) (param $key_ptr i32) (param $val i32)\n"
"  (local $num_buckets i32)\n"
"  (local $hash i32)\n"
"  (local $it i32)\n"
"  (local $node_size i32)\n"
"  (local $prev i32)\n"
"  (local $key_size i32)\n"
"  (local.set $key_size (i32.add (call $wax::str_len (local.get $key_ptr)) (i32.const 1)))\n"
"\n"
"  (local.set $num_buckets (call $wax::_map_get_num_buckets (local.get $m)))\n"
"  (local.set $hash (call $wax::_map_hash_h (local.get $num_buckets) (local.get $key_ptr) (local.get $key_size)))\n"
"  \n"
"  (local.set $it (call $wax::_map_get_bucket (local.get $m) (local.get $hash)))\n"
"  (local.set $node_size (i32.add (local.get $key_size) (i32.const 12) ))\n"
"\n"
"\n"
"  (if (i32.eqz (local.get $it))(then\n"
"    (local.set $it (call $wax::malloc (local.get $node_size)))\n"
"\n"
"    (call $wax::_mapnode_set_key_size (local.get $it) (local.get $key_size))\n"
"    (call $wax::_mapnode_set_next (local.get $it) (i32.const 0))\n"
"    (call $wax::_mapnode_set_key_h (local.get $it) (local.get $key_ptr) (local.get $key_size))\n"
"\n"
"    (call $wax::_map_set_bucket (local.get $m) (local.get $hash) (local.get $it))\n"
"\n"
"    (i32.store (call $wax::_mapnode_get_val_ptr (local.get $it)) (local.get $val))\n"
"    (call $wax::_map_inc_length (local.get $m) (i32.const 1))\n"
"    return\n"
"  )(else\n"
"    (local.set $prev (i32.const 0))\n"
"    loop $loop_map_set_h\n"
"      (if (i32.eqz (local.get $it))(then)(else\n"
"        (if (call $wax::_map_cmp_key_h (local.get $it) (local.get $key_ptr) (local.get $key_size) )(then\n"
"          (local.set $it (call $wax::realloc (local.get $it) (local.get $node_size)))\n"
"\n"
"          (if (i32.eqz (local.get $prev)) (then\n"
"            (call $wax::_map_set_bucket (local.get $m) (local.get $hash) (local.get $it))\n"
"          )(else\n"
"            (call $wax::_mapnode_set_next (local.get $prev) (local.get $it))\n"
"          ))\n"
"          (i32.store (call $wax::_mapnode_get_val_ptr (local.get $it)) (local.get $val))\n"
"          return\n"
"        ))\n"
"        (local.set $prev (local.get $it))\n"
"        (local.set $it (call $wax::_mapnode_get_next (local.get $it)))\n"
"        (br $loop_map_set_h)\n"
"      ))\n"
"    end\n"
"    (local.set $it (call $wax::malloc (local.get $node_size)))\n"
"    (call $wax::_mapnode_set_key_size (local.get $it) (local.get $key_size))\n"
"    (call $wax::_mapnode_set_next (local.get $it) (i32.const 0))\n"
"    (call $wax::_mapnode_set_key_h (local.get $it) (local.get $key_ptr) (local.get $key_size))\n"
"\n"
"    (call $wax::_mapnode_set_next (local.get $prev) (local.get $it))\n"
"    (i32.store (call $wax::_mapnode_get_val_ptr (local.get $it)) (local.get $val))\n"
"    (call $wax::_map_inc_length (local.get $m) (i32.const 1))\n"
"    return\n"
"  ))\n"
"\n"
")\n"
"\n"
";; insert a new entry to the map, taking a key passed directly as i32 argument\n"
";; m : the map\n"
";; key: the key\n"
";; returns pointer to the value inserted in the map for the user to write at\n"
"\n"
"(func $wax::map_set_i (param $m i32) (param $key i32)  (param $val i32)\n"
"  (local $num_buckets i32)\n"
"  (local $hash i32)\n"
"  (local $it i32)\n"
"  (local $node_size i32)\n"
"  (local $prev i32)\n"
"\n"
"  (local.set $num_buckets (call $wax::_map_get_num_buckets (local.get $m)))\n"
"  (local.set $hash (call $wax::_map_hash_i (local.get $num_buckets) (local.get $key)))\n"
"  \n"
"  (local.set $it (call $wax::_map_get_bucket (local.get $m) (local.get $hash)))\n"
"  (local.set $node_size (i32.const 16) )\n"
"\n"
"\n"
"  (if (i32.eqz (local.get $it))(then\n"
"    (local.set $it (call $wax::malloc (local.get $node_size)))\n"
"\n"
"    (call $wax::_mapnode_set_key_size (local.get $it) (i32.const 4))\n"
"    (call $wax::_mapnode_set_next (local.get $it) (i32.const 0))\n"
"    (call $wax::_mapnode_set_key_i (local.get $it) (local.get $key))\n"
"\n"
"    (call $wax::_map_set_bucket (local.get $m) (local.get $hash) (local.get $it))\n"
"\n"
"    (i32.store (call $wax::_mapnode_get_val_ptr (local.get $it)) (local.get $val))\n"
"    (call $wax::_map_inc_length (local.get $m) (i32.const 1))\n"
"    return\n"
"  )(else\n"
"    (local.set $prev (i32.const 0))\n"
"    loop $loop_map_set_i\n"
"      (if (i32.eqz (local.get $it))(then)(else\n"
"        (if (call $wax::_map_cmp_key_i (local.get $it) (local.get $key) )(then\n"
"          (local.set $it (call $wax::realloc (local.get $it) (local.get $node_size)))\n"
"\n"
"          (if (i32.eqz (local.get $prev)) (then\n"
"            (call $wax::_map_set_bucket (local.get $m) (local.get $hash) (local.get $it))\n"
"          )(else\n"
"            (call $wax::_mapnode_set_next (local.get $prev) (local.get $it))\n"
"          ))\n"
"          (i32.store (call $wax::_mapnode_get_val_ptr (local.get $it)) (local.get $val))\n"
"          return\n"
"        ))\n"
"        (local.set $prev (local.get $it))\n"
"        (local.set $it (call $wax::_mapnode_get_next (local.get $it)))\n"
"        (br $loop_map_set_i)\n"
"      ))\n"
"    end\n"
"    (local.set $it (call $wax::malloc (local.get $node_size)))\n"
"    (call $wax::_mapnode_set_key_size (local.get $it) (i32.const 4))\n"
"    (call $wax::_mapnode_set_next (local.get $it) (i32.const 0))\n"
"    (call $wax::_mapnode_set_key_i (local.get $it) (local.get $key))\n"
"\n"
"    (call $wax::_mapnode_set_next (local.get $prev) (local.get $it))\n"
"    (i32.store (call $wax::_mapnode_get_val_ptr (local.get $it)) (local.get $val))\n"
"    (call $wax::_map_inc_length (local.get $m) (i32.const 1))\n"
"    return\n"
"  ))\n"
"\n"
")\n"
"\n"
";; lookup a key for its value in the map, taking a key stored on the heap\n"
";; m : the map\n"
";; key_ptr: pointer to the key on the heap\n"
";; key_size: size of the key in bytes\n"
";; returns pointer to the value in the map, NULL (0) if not found.\n"
"\n"
"(func $wax::map_get_h (param $m i32) (param $key_ptr i32) (result i32)\n"
"  (local $num_buckets i32)\n"
"  (local $hash i32)\n"
"  (local $it i32)\n"
"  (local $key_size i32)\n"
"  (local.set $key_size (i32.add (call $wax::str_len (local.get $key_ptr)) (i32.const 1)))\n"
"\n"
"  (local.set $num_buckets (call $wax::_map_get_num_buckets (local.get $m)))\n"
"  (local.set $hash (call $wax::_map_hash_h (local.get $num_buckets) (local.get $key_ptr) (local.get $key_size)))\n"
"  (local.set $it (call $wax::_map_get_bucket (local.get $m) (local.get $hash)))\n"
"\n"
"  loop $loop_map_get_h\n"
"    (if (i32.eqz (local.get $it))(then)(else\n"
"      (if (call $wax::_map_cmp_key_h (local.get $it) (local.get $key_ptr) (local.get $key_size) )(then\n"
"        (i32.load (call $wax::_mapnode_get_val_ptr (local.get $it)))\n"
"        return\n"
"      ))\n"
"      (local.set $it (call $wax::_mapnode_get_next (local.get $it)))\n"
"      (br $loop_map_get_h)\n"
"    ))\n"
"  end\n"
"\n"
"  (i32.const 0)\n"
")\n"
"\n"
";; lookup a key for its value in the map, taking a key passed directly as i32 argument\n"
";; m : the map\n"
";; key : the key\n"
";; returns pointer to the value in the map, NULL (0) if not found.\n"
"\n"
"(func $wax::map_get_i (param $m i32) (param $key i32) (result i32)\n"
"  (local $num_buckets i32)\n"
"  (local $hash i32)\n"
"  (local $it i32)\n"
"\n"
"  (local.set $num_buckets (call $wax::_map_get_num_buckets (local.get $m)))\n"
"  (local.set $hash (call $wax::_map_hash_i (local.get $num_buckets) (local.get $key)))\n"
"  (local.set $it (call $wax::_map_get_bucket (local.get $m) (local.get $hash)))\n"
"\n"
"  loop $loop_map_get_i\n"
"    (if (i32.eqz (local.get $it))(then)(else\n"
"      (if (call $wax::_map_cmp_key_i (local.get $it) (local.get $key) )(then\n"
"        (i32.load (call $wax::_mapnode_get_val_ptr (local.get $it)))\n"
"        return\n"
"      ))\n"
"      (local.set $it (call $wax::_mapnode_get_next (local.get $it)))\n"
"      (br $loop_map_get_i)\n"
"    ))\n"
"  end\n"
"\n"
"  (i32.const 0)\n"
")\n"
"\n"
";; remove a key-value pair from the map, given a key stored on the heap\n"
";; m : the map\n"
";; key_ptr: pointer to the key on the heap\n"
";; key_size: size of the key in bytes\n"
"\n"
"(func $wax::map_remove_h (param $m i32) (param $key_ptr i32) (param $key_size i32)\n"
"  (local $num_buckets i32)\n"
"  (local $hash i32)\n"
"  (local $it i32)\n"
"  (local $prev i32)\n"
"  (local $next i32)\n"
"\n"
"  (local.set $num_buckets (call $wax::_map_get_num_buckets (local.get $m)))\n"
"  (local.set $hash (call $wax::_map_hash_h (local.get $num_buckets) (local.get $key_ptr) (local.get $key_size)))\n"
"  (local.set $it (call $wax::_map_get_bucket (local.get $m) (local.get $hash)))\n"
"  \n"
"  (local.set $prev (i32.const 0))\n"
"\n"
"  loop $loop_map_remove_h\n"
"    (if (i32.eqz (local.get $it))(then)(else\n"
"      (if (call $wax::_map_cmp_key_h (local.get $it) (local.get $key_ptr) (local.get $key_size) )(then\n"
"        (local.set $next (call $wax::_mapnode_get_next (local.get $it)))\n"
"\n"
"        (if (i32.eqz (local.get $prev)) (then\n"
"          (call $wax::_map_set_bucket (local.get $m) (local.get $hash) (local.get $next))\n"
"        )(else\n"
"          (call $wax::_mapnode_set_next (local.get $prev) (local.get $next))\n"
"        ))\n"
"        (call $wax::free (local.get $it))\n"
"        (call $wax::_map_inc_length (local.get $m) (i32.const -1))\n"
"        return\n"
"      ))\n"
"      (local.set $prev (local.get $it))\n"
"      (local.set $it (local.get $next))\n"
"      (br $loop_map_remove_h)\n"
"    ))\n"
"  end\n"
")\n"
"\n"
";; remove a key-value pair from the map, given a key passed directly as i32 argument\n"
";; m : the map\n"
";; key : the key\n"
"(func $wax::map_remove_i (param $m i32) (param $key i32)\n"
"  (local $num_buckets i32)\n"
"  (local $hash i32)\n"
"  (local $it i32)\n"
"  (local $prev i32)\n"
"  (local $next i32)\n"
"\n"
"  (local.set $num_buckets (call $wax::_map_get_num_buckets (local.get $m)))\n"
"  (local.set $hash (call $wax::_map_hash_i (local.get $num_buckets) (local.get $key)))\n"
"  (local.set $it (call $wax::_map_get_bucket (local.get $m) (local.get $hash)))\n"
"  \n"
"  (local.set $prev (i32.const 0))\n"
"\n"
"  loop $loop_map_remove_i\n"
"    (if (i32.eqz (local.get $it))(then)(else\n"
"      (if (call $wax::_map_cmp_key_i (local.get $it) (local.get $key) )(then\n"
"        (local.set $next (call $wax::_mapnode_get_next (local.get $it)))\n"
"\n"
"        (if (i32.eqz (local.get $prev)) (then\n"
"          (call $wax::_map_set_bucket (local.get $m) (local.get $hash) (local.get $next))\n"
"        )(else\n"
"          (call $wax::_mapnode_set_next (local.get $prev) (local.get $next))\n"
"        ))\n"
"        (call $wax::free (local.get $it))\n"
"        (call $wax::_map_inc_length (local.get $m) (i32.const 1))\n"
"        return\n"
"      ))\n"
"      (local.set $prev (local.get $it))\n"
"      (local.set $it (local.get $next))\n"
"      (br $loop_map_remove_i)\n"
"    ))\n"
"  end\n"
")\n"
"\n"
"\n"
";; generate a new iterator for traversing map pairs\n"
";; in effect, this returns a pointer to the first node\n"
"(func $wax::map_iter_new  (param $m i32) (result i32)\n"
"  (local $num_buckets i32)\n"
"  (local $i i32)\n"
"  (local $node i32)\n"
"\n"
"  (local.set $num_buckets (call $wax::_map_get_num_buckets (local.get $m)))\n"
"\n"
"  (local.set $i (i32.const 0))\n"
"  loop $loop_map_iter_new\n"
"    (local.set $node (call $wax::_map_get_bucket (local.get $m) (local.get $i)))\n"
"    (if (i32.eqz (local.get $node))(then)(else\n"
"      (local.get $node)\n"
"      return\n"
"    ))\n"
"    (local.set $i (i32.add (local.get $i) (i32.const 1)))\n"
"    (br_if $loop_map_iter_new (i32.lt_u (local.get $i) (local.get $num_buckets) ))\n"
"  end\n"
"  (i32.const 0)\n"
"  return\n"
")\n"
"\n"
";; increment an interator for traversing map pairs\n"
";; in effect, this finds the next node of a given node, by first looking\n"
";; at the linked list, then re-hashing the key to look through the rest of the hash table\n"
"(func $wax::map_iter_next (param $m i32) (param $iter i32) (result i32)\n"
"  (local $next i32)\n"
"  (local $num_buckets i32)\n"
"  (local $node i32)\n"
"  (local $i i32)\n"
"  \n"
"  (local.set $num_buckets (call $wax::_map_get_num_buckets (local.get $m)))\n"
"\n"
"  (local.set $next (call $wax::_mapnode_get_next (local.get $iter)))\n"
"\n"
"  (if (i32.eqz (local.get $next))(then\n"
"\n"
"    (local.set $i (i32.add (call $wax::_map_hash_h\n"
"      (local.get $num_buckets)\n"
"      (call $wax::_mapnode_get_key_ptr  (local.get $iter))\n"
"      (call $wax::_mapnode_get_key_size (local.get $iter))\n"
"    ) (i32.const 1)))\n"
"\n"
"    \n"
"    (if (i32.eq (local.get $i) (local.get $num_buckets)) (then\n"
"      (i32.const 0)\n"
"      return\n"
"    ))\n"
"    \n"
"    loop $loop_map_iter_next\n"
"      (local.set $node (call $wax::_map_get_bucket (local.get $m) (local.get $i)))\n"
"      (if (i32.eqz (local.get $node))(then)(else\n"
"        (local.get $node)\n"
"        return\n"
"      ))\n"
"      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n"
"      (br_if $loop_map_iter_next (i32.lt_u (local.get $i) (local.get $num_buckets) ))\n"
"    end\n"
"\n"
"    (i32.const 0)\n"
"    return\n"
"\n"
"  )(else\n"
"    (local.get $next)\n"
"    return\n"
"  ))\n"
"  (i32.const 0)\n"
"  return\n"
")\n"
"\n"
";; given a map iterator, get a pointer to the key stored\n"
"(func $wax::map_iter_key_h (param $iter i32) (result i32)\n"
"  (call $wax::_mapnode_get_key_ptr (local.get $iter))\n"
")\n"
";; given a map iterator, read the key stored as an int\n"
";; only works if your key is an i32\n"
"(func $wax::map_iter_key_i (param $iter i32) (result i32)\n"
"  (i32.load (call $wax::_mapnode_get_key_ptr (local.get $iter)))\n"
")\n"
";; given a map iterator, get a pointer to the value stored\n"
"(func $wax::map_iter_val (param $iter i32) (result i32)\n"
"  (i32.load (call $wax::_mapnode_get_val_ptr (local.get $iter)))\n"
")\n"
"\n"
";; remove all key-values in the map\n"
"(func $wax::map_clear (param $m i32)\n"
"  (local $num_buckets i32)\n"
"  (local $hash i32)\n"
"  (local $it i32)\n"
"\n"
"  (local $next i32)\n"
"\n"
"  (local.set $num_buckets (call $wax::_map_get_num_buckets (local.get $m)))\n"
"\n"
"  (local.set $hash (i32.const 0))\n"
"\n"
"  loop $loop_map_clear_buckets\n"
"\n"
"    (local.set $it (call $wax::_map_get_bucket (local.get $m) (local.get $hash)))\n"
"\n"
"    loop $loop_map_clear_nodes\n"
"      (if (i32.eqz (local.get $it))(then)(else\n"
"        (local.set $next (call $wax::_mapnode_get_next (local.get $it)))\n"
"\n"
"        (call $wax::free (local.get $it))\n"
"\n"
"        (local.set $it (local.get $next))\n"
"        (br $loop_map_clear_nodes)\n"
"      ))\n"
"    end\n"
"\n"
"    (call $wax::_map_set_bucket (local.get $m) (local.get $hash) (i32.const 0))\n"
"\n"
"    (local.set $hash (i32.add (local.get $hash) (i32.const 1)))\n"
"    (br_if $loop_map_clear_buckets (i32.lt_u (local.get $hash) (local.get $num_buckets)))\n"
"\n"
"  end  \n"
")\n"
"\n"
";; free all allocated memory for a map\n"
"(func $wax::map_free (param $m i32)\n"
"  (call $wax::map_clear (local.get $m))\n"
"  (call $wax::free (local.get $m))\n"
")\n";
const char* TEXT_std_stack_wat = ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
";;                                  ;;\n"
";;                                  ;;\n"
";;               STACK              ;;\n"
";;                                  ;;\n"
";;                                  ;;\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
";; poor man's stack\n"
";; malloc a block of memory and pretend it's the stack, because of the apparent lack(?) of stack address in webassembly\n"
"\n"
"(global $wax::stack_indices_ptr (mut i32) (i32.const 0))\n"
"(global $wax::stack_content_ptr (mut i32) (i32.const 0))\n"
"(global $wax::stack_count   (mut i32) (i32.const 32))\n"
"(global $wax::stack_size    (mut i32) (i32.const 128))\n"
"(global $wax::stack_index   (mut i32) (i32.const 0))\n"
"(global $wax::stack_now     (mut i32) (i32.const 0))\n"
"(global $wax::stack_did_init(mut i32) (i32.const 0))\n"
"\n"
"(func $wax::init_stack\n"
"  (global.set $wax::stack_indices_ptr (call $wax::calloc (i32.mul (global.get $wax::stack_count) (i32.const 4))))\n"
"  (global.set $wax::stack_content_ptr (call $wax::malloc (global.get $wax::stack_size)))\n"
"  (global.set $wax::stack_index (i32.const 0))\n"
"  (global.set $wax::stack_did_init (i32.const 1))\n"
")\n"
"(func $wax::stack_index_offset (result i32)\n"
"  (i32.add (global.get $wax::stack_indices_ptr) (i32.mul (global.get $wax::stack_index) (i32.const 4)))\n"
")\n"
"(func $wax::push_stack\n"
"\n"
"  (if (i32.eqz (global.get $wax::stack_did_init)) (then (call $wax::init_stack) ))\n"
"\n"
"  (global.set $wax::stack_index (i32.add (global.get $wax::stack_index) (i32.const 1) ))\n"
"\n"
"  (if (i32.ge_u (global.get $wax::stack_index) (global.get $wax::stack_count)) (then\n"
"    (global.set $wax::stack_count (i32.add (global.get $wax::stack_count) (i32.const 128)))\n"
"    (global.set $wax::stack_indices_ptr (call $wax::realloc \n"
"      (global.get $wax::stack_indices_ptr) \n"
"      (i32.mul (global.get $wax::stack_count) (i32.const 4))\n"
"    ))\n"
"  ))\n"
"\n"
"  (i32.store (call $wax::stack_index_offset) (global.get $wax::stack_now) )\n"
"\n"
")\n"
"(func $wax::pop_stack\n"
"\n"
"  (global.set $wax::stack_now (i32.load (call $wax::stack_index_offset) ))\n"
"  (global.set $wax::stack_index (i32.sub (global.get $wax::stack_index) (i32.const 1) ))\n"
"  \n"
")\n"
"(func $wax::alloca (param $n_bytes i32) (result i32)\n"
"  (local $inc i32)\n"
"  (if (i32.ge_u (i32.add (global.get $wax::stack_now) (local.get $n_bytes) ) (global.get $wax::stack_size)) (then\n"
"    (local.set $inc (i32.const 512))\n"
"    (if (i32.gt_u (local.get $n_bytes) (local.get $inc)) (then\n"
"      (local.set $inc (call $wax::align4 (local.get $n_bytes)))\n"
"    ))\n"
"    (global.set $wax::stack_size (i32.add (global.get $wax::stack_size) (local.get $inc) ))\n"
"    (global.set $wax::stack_content_ptr\n"
"      (call $wax::realloc (global.get $wax::stack_content_ptr) (global.get $wax::stack_size))\n"
"    )\n"
"  ))\n"
"\n"
"  ;; repurpose $inc for ret val\n"
"  (local.set $inc (i32.add (global.get $wax::stack_content_ptr ) (global.get $wax::stack_now)))\n"
"\n"
"  (global.set $wax::stack_now (i32.add (global.get $wax::stack_now) (local.get $n_bytes)))\n"
"\n"
"  (local.get $inc)\n"
"  return\n"
")\n";

#endif
